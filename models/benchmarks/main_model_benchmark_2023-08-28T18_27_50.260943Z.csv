Execution;Time in ms in Scope #138 of main_model(0);Invocations in Scope #138 of main_model(0);Time in ms in Scope #134 (in ExperimentPlan);Invocations in Scope #134 (in ExperimentPlan);Time in ms in Scope #136 of Benchmarking(0);Invocations in Scope #136 of Benchmarking(0)
model main

global ;;;;;;
agent host ;0;1;;;;
-29;;;;;;
list<main_model> peers ;0;1;;;;
-199;;;;;;
main_model world ;0;1;;;;
-27;;;;;;
experiment experiment ;0;1;;;;
-31;;;;;;
float step <- 2 * #sec ;0;1;;;;
2 * #sec;;;;;;
date starting_date <- date('2019-10-07 00:00:00') ;0;1;;;;
date('2019-10-07 00:00:00');0;1;;;;
date logDate <- date('2023-08-28 09:00:00') ;0;1;;;;
date('2023-08-28 09:00:00');0;1;;;;
date nowDate <- #now ;0;1;;;;
int numberOfWeeks <- 2 ;0;1;;;;
int numberOfDays <- 7 ;0;1;;;;
int numberOfHours <- 24 ;0;1;;;;
bool peopleEnabled <- true ;0;1;;;;
bool packagesEnabled <- true ;0;1;;;;
bool biddingEnabled <- true ;0;1;;;;
bool dynamicFleetsizing <- false ;0;1;;;;
bool loggingEnabled <- true ;0;1;;;;
bool printsEnabled <- false ;0;1;;;;
bool autonomousBikeEventLog <- false ;0;1;;;;
bool peopleTripLog <- true ;0;1;;;;
bool peopleEventLog <- false ;0;1;;;;
bool packageTripLog <- true ;0;1;;;;
bool packageEventLog <- false ;0;1;;;;
bool stationChargeLogs <- true ;0;1;;;;
bool roadsTraveledLog <- false ;0;1;;;;
int numAutonomousBikes <- 0 ;0;1;;;;
float maxBatteryLifeAutonomousBike <- 70000.0 * #m min: 30000 * #m max: 100000 * #m parameter: 'Autonomous Bike Battery Capacity (m):' category: 'Bike' ;0;1;;;;
70000.0 * #m;;;;;;
30000 * #m;0;1;;;;
100000 * #m;0;1;;;;
float DrivingSpeedAutonomousBike <- (8 / (3.6 * #m)) / #sec min: (1 / (3.6 * #m)) / #sec max: (15 / (3.6 * #m)) / #sec parameter: 'Autonomous Bike Driving Speed (m/s):' category: 'Bike' ;0;1;;;;
(8 / (3.6 * #m)) / #sec;;;;;;
8 / (3.6 * #m);;;;;;
3.6 * #m;;;;;;
(1 / (3.6 * #m)) / #sec;0;1;;;;
1 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
(15 / (3.6 * #m)) / #sec;0;1;;;;
15 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
float minSafeBatteryAutonomousBike <- 0.25 * (maxBatteryLifeAutonomousBike * #m) ;0;1;;;;
0.25 * (maxBatteryLifeAutonomousBike * #m);0;1;;;;
maxBatteryLifeAutonomousBike * #m;0;1;;;;
int maxBiddingTime <- 0 min: 0 max: 60 parameter: 'Maximum bidding time' ;0;1;;;;
float pack_bid_ct <- 100.0 ;0;1;;;;
float pack_bid_dist_coef <- 1 / 100 ;0;1;;;;
1 / 100;0;1;;;;
float pack_bid_queue_coef <- 2.0 ;0;1;;;;
float person_bid_ct <- 200.0 ;0;1;;;;
float person_bid_dist_coef <- 1 / 100 ;0;1;;;;
1 / 100;0;1;;;;
float person_bid_queue_coef <- 2.0 ;0;1;;;;
int chargingStationCapacity <- 16 ;0;1;;;;
float V2IChargingRate <- (maxBatteryLifeAutonomousBike / (111 * #m)) / #sec ;0;1;;;;
(maxBatteryLifeAutonomousBike / (111 * #m)) / #sec;0;1;;;;
maxBatteryLifeAutonomousBike / (111 * #m);0;1;;;;
111 * #m;0;1;;;;
float maxWaitTimePeople <- 15 * #minute min: 3 * #minute max: 25 * #minute parameter: 'Max Wait Time People:' category: 'People' ;0;1;;;;
15 * #minute;;;;;;
3 * #minute;0;1;;;;
25 * #minute;0;1;;;;
float maxDistancePeople_AutonomousBike <- maxWaitTimePeople * (DrivingSpeedAutonomousBike * #m) ;0;1;;;;
maxWaitTimePeople * (DrivingSpeedAutonomousBike * #m);0;1;;;;
DrivingSpeedAutonomousBike * #m;0;1;;;;
float peopleSpeed <- (5 / (3.6 * #m)) / #sec min: (3 / (3.6 * #m)) / #sec max: (7 / (3.6 * #m)) / #sec parameter: 'People Speed (m/s):' category: 'People' ;0;1;;;;
(5 / (3.6 * #m)) / #sec;;;;;;
5 / (3.6 * #m);;;;;;
3.6 * #m;;;;;;
(3 / (3.6 * #m)) / #sec;0;1;;;;
3 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
(7 / (3.6 * #m)) / #sec;0;1;;;;
7 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
float RidingSpeedAutonomousBike <- 10.2 / 3.6 min: (8 / (3.6 * #m)) / #sec max: (15 / (3.6 * #m)) / #sec parameter: 'Autonomous Bike Riding Speed (m/s):' category: 'Bike' ;0;1;;;;
10.2 / 3.6;;;;;;
(8 / (3.6 * #m)) / #sec;0;1;;;;
8 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
(15 / (3.6 * #m)) / #sec;0;1;;;;
15 / (3.6 * #m);0;1;;;;
3.6 * #m;0;1;;;;
float maxWaitTimePackage <- 40 * #minute min: 10 * #minute max: 60 * #minute parameter: 'Max Wait Time Package:' category: 'Package' ;0;1;;;;
40 * #minute;;;;;;
10 * #minute;0;1;;;;
60 * #minute;0;1;;;;
float maxDistancePackage_AutonomousBike <- maxWaitTimePackage * (DrivingSpeedAutonomousBike * #m) ;0;1;;;;
maxWaitTimePackage * (DrivingSpeedAutonomousBike * #m);0;1;;;;
DrivingSpeedAutonomousBike * #m;0;1;;;;
string cityDemandFolder <- './../includes/Demand' ;0;1;;;;
file<point, unknown> demand_csv <- csv_file(cityDemandFolder + '/user_week_weekendfirst.csv',true) ;1;1;;;;
csv_file(cityDemandFolder + '/user_week_weekendfirst.csv',true);1;1;;;;
cityDemandFolder + '/user_week_weekendfirst.csv';0;1;;;;
file<point, unknown> pdemand_csv <- csv_file(cityDemandFolder + '/food_demand_cambridge_week_weekendfirst.csv',true) ;0;1;;;;
csv_file(cityDemandFolder + '/food_demand_cambridge_week_weekendfirst.csv',true);0;1;;;;
cityDemandFolder + '/food_demand_cambridge_week_weekendfirst.csv';0;1;;;;
bool rebalEnabled <- true ;0;1;;;;
file<point, unknown> food_hotspot_csv <- csv_file(cityDemandFolder + '/food_top5density.csv',true) ;0;1;;;;
csv_file(cityDemandFolder + '/food_top5density.csv',true);0;1;;;;
cityDemandFolder + '/food_top5density.csv';0;1;;;;
file<point, unknown> user_hotspot_csv <- csv_file(cityDemandFolder + '/user_top10density.csv',true) ;0;1;;;;
csv_file(cityDemandFolder + '/user_top10density.csv',true);0;1;;;;
cityDemandFolder + '/user_top10density.csv';0;1;;;;
string cityScopeCity <- 'Cambridge' ;0;1;;;;
string residence <- 'R' ;0;1;;;;
string office <- 'O' ;0;1;;;;
string park <- 'P' ;0;1;;;;
string health <- 'H' ;0;1;;;;
string education <- 'E' ;0;1;;;;
string usage <- 'usage' ;0;1;;;;
map<string, rgb> color_map <-  [residence::#silver,office::#silver,'Other'::#silver]  ;0;1;;;;
 [residence::#silver,office::#silver,'Other'::#silver] ;0;1;;;;
string cityGISFolder <- './../includes/City/' + cityScopeCity ;0;1;;;;
'./../includes/City/' + cityScopeCity;0;1;;;0;2
file<unknown, string> bound_shapefile <- file<unknown, string>(cityGISFolder + '/Bounds.shp') parameter: 'Bounds Shapefile:' category: 'GIS' ;0;1;;;;
file<unknown, string>(cityGISFolder + '/Bounds.shp');;;;;1;1
cityGISFolder + '/Bounds.shp';;;;;0;1
file<unknown, string> roads_shapefile <- file<unknown, string>(cityGISFolder + '/CambridgeRoads.shp') parameter: 'Road Shapefile:' category: 'GIS' ;0;1;;;;
file<unknown, string>(cityGISFolder + '/CambridgeRoads.shp');;;;;0;1
cityGISFolder + '/CambridgeRoads.shp';;;;;0;1
file<point, unknown> chargingStations_csv <- csv_file(cityGISFolder + '/bluebikes_stations_cambridge.csv',true) ;0;1;;;;
csv_file(cityGISFolder + '/bluebikes_stations_cambridge.csv',true);0;1;;;;
cityGISFolder + '/bluebikes_stations_cambridge.csv';0;1;;;;
bool show_road <- true ;0;1;;;;
bool show_people <- true ;0;1;;;;
bool show_chargingStation <- true ;0;1;;;;
bool show_package <- true ;0;1;;;;
bool show_autonomousBike <- true ;0;1;;;;
map<string, string> filenames <- [] ;0;1;;;;
[];0;1;;;;
geometry shape <- envelope(bound_shapefile) ;7;1;;;;
envelope(bound_shapefile);6;1;;;;
graph roadNetwork ;0;1;;;;
list<int> chargingStationLocation ;0;1;;;;
int trips_w_good_service <- 0 ;0;1;;;;
list<Logger> Logger ;0;1;;;;
list<peopleLogger_trip> peopleLogger_trip ;0;1;;;;
list<packageLogger_trip> packageLogger_trip ;0;1;;;;
list<peopleLogger> peopleLogger ;0;1;;;;
list<packageLogger> packageLogger ;0;1;;;;
list<autonomousBikeLogger_chargeEvents> autonomousBikeLogger_chargeEvents ;0;1;;;;
list<autonomousBikeLogger_roadsTraveled> autonomousBikeLogger_roadsTraveled ;0;1;;;;
list<autonomousBikeLogger_event> autonomousBikeLogger_event ;0;1;;;;
list<road> road ;0;1;;;;
list<CellcenterPoint> CellcenterPoint ;0;1;;;;
list<chargingStation> chargingStation ;0;1;;;;
list<restaurant> restaurant ;0;1;;;;
list<foodhotspot> foodhotspot ;0;1;;;;
list<userhotspot> userhotspot ;0;1;;;;
list<package> package ;0;1;;;;
list<people> people ;0;1;;;;
list<autonomousBike> autonomousBike ;0;1;;;;
list<cell> cell ;1;1;;;;
action registerLogFile (string filename);0;3;;;;
arg filename type: string ;0;3;;;;
put ((('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + filename) + '.csv' at: filename to: filenames ;0;3;;;;
((('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + filename) + '.csv';0;3;;;;
(('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + filename;0;3;;;;
('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/';0;3;;;;
'./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'));0;3;;;;
string(logDate,'yyyy-MM-dd hh.mm.ss','en');0;3;;;;
action log (string filename, list data, list<string> columns);4310;7758;;;;
arg filename type: string ;1;7758;;;;
arg data type: list ;1;7758;;;;
arg columns type: list<string> ;1;7758;;;;
if not(filename in filenames.keys) ;40;7758;;;;
not(filename in filenames.keys);31;7758;;;;
filename in filenames.keys;23;7758;;;;
filenames.keys;16;7758;;;;
do registerLogFile (filename:filename);0;3;;;;
self.registerLogFile(filename:filename);;;;;;
save (['Cycle','Day','Time','NumBikes','Battery','AutDrivingSpeed','MaxBiddingTime','PackBidCt','PackBidDist','PackBidQueue','PersonBidCt','PersonBidDist','PersonBidQueue','Agent']) + columns to: filenames[filename] format: csv rewrite: false header: false ;4;3;;;;
filenames[filename];0;6;;;;
[filename];0;6;;;;
(['Cycle','Day','Time','NumBikes','Battery','AutDrivingSpeed','MaxBiddingTime','PackBidCt','PackBidDist','PackBidQueue','PersonBidCt','PersonBidDist','PersonBidQueue','Agent']) + columns;0;3;;;;
['Cycle','Day','Time','NumBikes','Battery','AutDrivingSpeed','MaxBiddingTime','PackBidCt','PackBidDist','PackBidQueue','PersonBidCt','PersonBidDist','PersonBidQueue','Agent'];0;3;;;;
if loggingEnabled ;4120;7758;;;;
save ([cycle,current_date.day,string(current_date,'HH:mm:ss'),numAutonomousBikes,maxBatteryLifeAutonomousBike,DrivingSpeedAutonomousBike * 3.6,maxBiddingTime,pack_bid_ct,pack_bid_dist_coef,pack_bid_queue_coef,person_bid_ct,person_bid_dist_coef,person_bid_queue_coef]) + data to: filenames[filename] format: csv rewrite: false header: false ;4103;7758;;;;
filenames[filename];48;15516;;;;
[filename];29;15516;;;;
([cycle,current_date.day,string(current_date,'HH:mm:ss'),numAutonomousBikes,maxBatteryLifeAutonomousBike,DrivingSpeedAutonomousBike * 3.6,maxBiddingTime,pack_bid_ct,pack_bid_dist_coef,pack_bid_queue_coef,person_bid_ct,person_bid_dist_coef,person_bid_queue_coef]) + data;131;7758;;;;
[cycle,current_date.day,string(current_date,'HH:mm:ss'),numAutonomousBikes,maxBatteryLifeAutonomousBike,DrivingSpeedAutonomousBike * 3.6,maxBiddingTime,pack_bid_ct,pack_bid_dist_coef,pack_bid_queue_coef,person_bid_ct,person_bid_dist_coef,person_bid_queue_coef];86;7758;;;;
current_date.day;6;7758;;;;
string(current_date,'HH:mm:ss');18;7758;;;;
DrivingSpeedAutonomousBike * 3.6;10;7758;;;;
if printsEnabled ;4;7758;;;;
write ([cycle,current_date.day,string(current_date,'HH:mm:ss')]) + data ;;;;;;
([cycle,current_date.day,string(current_date,'HH:mm:ss')]) + data;;;;;;
[cycle,current_date.day,string(current_date,'HH:mm:ss')];;;;;;
current_date.day;;;;;;
string(current_date,'HH:mm:ss');;;;;;
action logForSetUp (list<string> parameters);17;1;;;;
arg parameters type: list<string> ;0;1;;;;
loop param over: parameters ;17;1;;;;
save param to: ((('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + 'setUp') + '.txt' format: text rewrite: false header: false ;17;43;;;;
((('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + 'setUp') + '.txt';2;86;;;;
(('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/') + 'setUp';2;86;;;;
('./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'))) + '/';2;86;;;;
'./../results/' + (string(logDate,'yyyy-MM-dd hh.mm.ss','en'));2;86;;;;
string(logDate,'yyyy-MM-dd hh.mm.ss','en');2;86;;;;
action logSetUp ;17;1;;;;
let parameters type: list<string> value: ['NAutonomousBikes: ' + string(numAutonomousBikes),'MaxWaitPeople: ' + string(maxWaitTimePeople / 60),'MaxWaitPackage: ' + string(maxWaitTimePackage / 60),'------------------------------SIMULATION PARAMETERS------------------------------','Step: ' + string(step),'Starting Date: ' + string(starting_date),'Number of Days of Simulation: ' + string(numberOfDays),'Number ot Hours of Simulation (if less than one day): ' + string(numberOfHours),'People enabled: ' + string(peopleEnabled),'Pakcages enabled: ' + string(packagesEnabled),'Bidding enabled: ' + string(biddingEnabled),'------------------------------BIKE PARAMETERS------------------------------','Number of Bikes: ' + string(numAutonomousBikes),'Max Battery Life of Bikes [km]: ' + string(maxBatteryLifeAutonomousBike / with_precision(float(1000),2)),'Autonomous driving speed [km/h]: ' + string(DrivingSpeedAutonomousBike * 3.6),'Minimum Battery [%]: ' + string((minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike) * 100),'------------------------------BIDDING PARAMETERS------------------------------','Maximum bidding time [min]' + string(maxBiddingTime),'Package bidding constant: ' + string(pack_bid_ct),'Package distance coefficient (-):' + string(pack_bid_dist_coef),'Package queue time coefficient: ' + string(pack_bid_queue_coef),'Person bidding constant: ' + string(person_bid_ct),'Person distance coefficient (-): ' + string(person_bid_dist_coef),'Person queue time coefficient: ' + string(person_bid_queue_coef),'------------------------------PEOPLE PARAMETERS------------------------------','Maximum Wait Time People [min]: ' + string(maxWaitTimePeople / 60),'Walking Speed [km/h]: ' + string(peopleSpeed * 3.6),'Riding Speed Autonomous Bike [km/h]: ' + string(RidingSpeedAutonomousBike * 3.6),'------------------------------PACKAGE PARAMETERS------------------------------','Maximum Wait Time Package [min]: ' + string(maxWaitTimePackage / 60),'------------------------------STATION PARAMETERS------------------------------','V2I Charging Rate: ' + string(with_precision(V2IChargingRate,2)),'------------------------------MAP PARAMETERS------------------------------','City Map Name: ' + string(cityScopeCity),'------------------------------LOGGING PARAMETERS------------------------------','Print Enabled: ' + string(printsEnabled),'Autonomous Bike Event/Trip Log: ' + string(autonomousBikeEventLog),'People Trip Log: ' + string(peopleTripLog),'Package Trip Log: ' + string(packageTripLog),'People Event Log: ' + string(peopleEventLog),'Package Event Log:' + string(packageEventLog),'Station Charge Log: ' + string(stationChargeLogs),'Roads Traveled Log: ' + string(roadsTraveledLog)] ;0;1;;;;
['NAutonomousBikes: ' + string(numAutonomousBikes),'MaxWaitPeople: ' + string(maxWaitTimePeople / 60),'MaxWaitPackage: ' + string(maxWaitTimePackage / 60),'------------------------------SIMULATION PARAMETERS------------------------------','Step: ' + string(step),'Starting Date: ' + string(starting_date),'Number of Days of Simulation: ' + string(numberOfDays),'Number ot Hours of Simulation (if less than one day): ' + string(numberOfHours),'People enabled: ' + string(peopleEnabled),'Pakcages enabled: ' + string(packagesEnabled),'Bidding enabled: ' + string(biddingEnabled),'------------------------------BIKE PARAMETERS------------------------------','Number of Bikes: ' + string(numAutonomousBikes),'Max Battery Life of Bikes [km]: ' + string(maxBatteryLifeAutonomousBike / with_precision(float(1000),2)),'Autonomous driving speed [km/h]: ' + string(DrivingSpeedAutonomousBike * 3.6),'Minimum Battery [%]: ' + string((minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike) * 100),'------------------------------BIDDING PARAMETERS------------------------------','Maximum bidding time [min]' + string(maxBiddingTime),'Package bidding constant: ' + string(pack_bid_ct),'Package distance coefficient (-):' + string(pack_bid_dist_coef),'Package queue time coefficient: ' + string(pack_bid_queue_coef),'Person bidding constant: ' + string(person_bid_ct),'Person distance coefficient (-): ' + string(person_bid_dist_coef),'Person queue time coefficient: ' + string(person_bid_queue_coef),'------------------------------PEOPLE PARAMETERS------------------------------','Maximum Wait Time People [min]: ' + string(maxWaitTimePeople / 60),'Walking Speed [km/h]: ' + string(peopleSpeed * 3.6),'Riding Speed Autonomous Bike [km/h]: ' + string(RidingSpeedAutonomousBike * 3.6),'------------------------------PACKAGE PARAMETERS------------------------------','Maximum Wait Time Package [min]: ' + string(maxWaitTimePackage / 60),'------------------------------STATION PARAMETERS------------------------------','V2I Charging Rate: ' + string(with_precision(V2IChargingRate,2)),'------------------------------MAP PARAMETERS------------------------------','City Map Name: ' + string(cityScopeCity),'------------------------------LOGGING PARAMETERS------------------------------','Print Enabled: ' + string(printsEnabled),'Autonomous Bike Event/Trip Log: ' + string(autonomousBikeEventLog),'People Trip Log: ' + string(peopleTripLog),'Package Trip Log: ' + string(packageTripLog),'People Event Log: ' + string(peopleEventLog),'Package Event Log:' + string(packageEventLog),'Station Charge Log: ' + string(stationChargeLogs),'Roads Traveled Log: ' + string(roadsTraveledLog)];0;1;;;;
'NAutonomousBikes: ' + string(numAutonomousBikes);0;1;;;;
string(numAutonomousBikes);0;1;;;;
'MaxWaitPeople: ' + string(maxWaitTimePeople / 60);0;1;;;;
string(maxWaitTimePeople / 60);0;1;;;;
maxWaitTimePeople / 60;0;1;;;;
'MaxWaitPackage: ' + string(maxWaitTimePackage / 60);0;1;;;;
string(maxWaitTimePackage / 60);0;1;;;;
maxWaitTimePackage / 60;0;1;;;;
'Step: ' + string(step);0;1;;;;
string(step);0;1;;;;
'Starting Date: ' + string(starting_date);0;1;;;;
string(starting_date);0;1;;;;
'Number of Days of Simulation: ' + string(numberOfDays);0;1;;;;
string(numberOfDays);0;1;;;;
'Number ot Hours of Simulation (if less than one day): ' + string(numberOfHours);0;1;;;;
string(numberOfHours);0;1;;;;
'People enabled: ' + string(peopleEnabled);0;1;;;;
string(peopleEnabled);0;1;;;;
'Pakcages enabled: ' + string(packagesEnabled);0;1;;;;
string(packagesEnabled);0;1;;;;
'Bidding enabled: ' + string(biddingEnabled);0;1;;;;
string(biddingEnabled);0;1;;;;
'Number of Bikes: ' + string(numAutonomousBikes);0;1;;;;
string(numAutonomousBikes);0;1;;;;
'Max Battery Life of Bikes [km]: ' + string(maxBatteryLifeAutonomousBike / with_precision(float(1000),2));0;1;;;;
string(maxBatteryLifeAutonomousBike / with_precision(float(1000),2));0;1;;;;
maxBatteryLifeAutonomousBike / with_precision(float(1000),2);0;1;;;;
with_precision(float(1000),2);0;1;;;;
float(1000);0;1;;;;
'Autonomous driving speed [km/h]: ' + string(DrivingSpeedAutonomousBike * 3.6);0;1;;;;
string(DrivingSpeedAutonomousBike * 3.6);0;1;;;;
DrivingSpeedAutonomousBike * 3.6;0;1;;;;
'Minimum Battery [%]: ' + string((minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike) * 100);0;1;;;;
string((minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike) * 100);0;1;;;;
(minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike) * 100;0;1;;;;
minSafeBatteryAutonomousBike / maxBatteryLifeAutonomousBike;0;1;;;;
'Maximum bidding time [min]' + string(maxBiddingTime);0;1;;;;
string(maxBiddingTime);0;1;;;;
'Package bidding constant: ' + string(pack_bid_ct);0;1;;;;
string(pack_bid_ct);0;1;;;;
'Package distance coefficient (-):' + string(pack_bid_dist_coef);0;1;;;;
string(pack_bid_dist_coef);0;1;;;;
'Package queue time coefficient: ' + string(pack_bid_queue_coef);0;1;;;;
string(pack_bid_queue_coef);0;1;;;;
'Person bidding constant: ' + string(person_bid_ct);0;1;;;;
string(person_bid_ct);0;1;;;;
'Person distance coefficient (-): ' + string(person_bid_dist_coef);0;1;;;;
string(person_bid_dist_coef);0;1;;;;
'Person queue time coefficient: ' + string(person_bid_queue_coef);0;1;;;;
string(person_bid_queue_coef);0;1;;;;
'Maximum Wait Time People [min]: ' + string(maxWaitTimePeople / 60);0;1;;;;
string(maxWaitTimePeople / 60);0;1;;;;
maxWaitTimePeople / 60;0;1;;;;
'Walking Speed [km/h]: ' + string(peopleSpeed * 3.6);0;1;;;;
string(peopleSpeed * 3.6);0;1;;;;
peopleSpeed * 3.6;0;1;;;;
'Riding Speed Autonomous Bike [km/h]: ' + string(RidingSpeedAutonomousBike * 3.6);0;1;;;;
string(RidingSpeedAutonomousBike * 3.6);0;1;;;;
RidingSpeedAutonomousBike * 3.6;0;1;;;;
'Maximum Wait Time Package [min]: ' + string(maxWaitTimePackage / 60);0;1;;;;
string(maxWaitTimePackage / 60);0;1;;;;
maxWaitTimePackage / 60;0;1;;;;
'V2I Charging Rate: ' + string(with_precision(V2IChargingRate,2));0;1;;;;
string(with_precision(V2IChargingRate,2));0;1;;;;
with_precision(V2IChargingRate,2);0;1;;;;
'City Map Name: ' + string(cityScopeCity);0;1;;;;
string(cityScopeCity);0;1;;;;
'Print Enabled: ' + string(printsEnabled);0;1;;;;
string(printsEnabled);0;1;;;;
'Autonomous Bike Event/Trip Log: ' + string(autonomousBikeEventLog);0;1;;;;
string(autonomousBikeEventLog);0;1;;;;
'People Trip Log: ' + string(peopleTripLog);0;1;;;;
string(peopleTripLog);0;1;;;;
'Package Trip Log: ' + string(packageTripLog);0;1;;;;
string(packageTripLog);0;1;;;;
'People Event Log: ' + string(peopleEventLog);0;1;;;;
string(peopleEventLog);0;1;;;;
'Package Event Log:' + string(packageEventLog);0;1;;;;
string(packageEventLog);0;1;;;;
'Station Charge Log: ' + string(stationChargeLogs);0;1;;;;
string(stationChargeLogs);0;1;;;;
'Roads Traveled Log: ' + string(roadsTraveledLog);0;1;;;;
string(roadsTraveledLog);0;1;;;;
do logForSetUp (parameters:parameters);17;1;;;;
self.logForSetUp(parameters:parameters);;;;;;
float distanceInGraph (point origin, point destination);12134;270020;;;;
arg origin type: point ;31;270020;;;;
arg destination type: point ;23;270020;;;;
let originIntersection type: point value: closest_to(roadNetwork.vertices,origin) ;3481;270020;;;;
closest_to(roadNetwork.vertices,origin);3282;270020;;;;
roadNetwork.vertices;194;270020;;;;
let destinationIntersection type: point value: closest_to(roadNetwork.vertices,destination) ;2841;270020;;;;
closest_to(roadNetwork.vertices,destination);2718;270020;;;;
roadNetwork.vertices;214;270020;;;;
if originIntersection = destinationIntersection ;4461;270020;;;;
originIntersection = destinationIntersection;109;270020;;;;
else ;4138;208726;;;;
return using(distance_to(originIntersection,destinationIntersection),topology(roadNetwork)) ;4054;208726;;;;
using(distance_to(originIntersection,destinationIntersection),topology(roadNetwork));3995;208726;;;;
distance_to(originIntersection,destinationIntersection);3721;208726;;;;
topology(roadNetwork);166;208726;;;;
return 0.0 ;19;61294;;;;
bool requestAutonomousBike (people person, package pack);21398;7431;;;;
arg person type: people ;0;7431;;;;
arg pack type: package ;1;7431;;;;
let available type: list<autonomousBike> value: autonomousBike where (each.availableForRideAB()) ;9777;7431;;;;
autonomousBike where (each.availableForRideAB());9756;7431;;;;
each.availableForRideAB();;;;;;
if empty(available) and dynamicFleetsizing ;55;7431;;;;
empty(available) and dynamicFleetsizing;6;7431;;;;
empty(available);4;7431;;;;
else ;11;7352;;;;
if empty(available) and !dynamicFleetsizing ;8;7352;;;;
empty(available) and !dynamicFleetsizing;7;7352;;;;
empty(available);2;7352;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;52;158;;;;
if person != nil ;22;79;;;;
person != nil;0;79;;;;
else ;22;79;;;;
if pack != nil ;22;79;;;;
pack != nil;1;79;;;;
write pack.my_cell.name ;17;79;;;;
pack.my_cell.name;0;79;;;;
pack.my_cell;0;79;;;;
let packIntersection type: point value: closest_to(roadNetwork.vertices,pack) ;4;79;;;;
closest_to(roadNetwork.vertices,pack);4;79;;;;
roadNetwork.vertices;0;79;;;;
set location value: point(packIntersection) ;0;79;;;;
point(packIntersection);0;79;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;0;79;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);0;79;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;0;79;;;;
numAutonomousBikes + 1;0;79;;;;
write person.my_cell.name ;;;;;;
person.my_cell.name;;;;;;
person.my_cell;;;;;;
let personIntersection type: point value: closest_to(roadNetwork.vertices,person) ;;;;;;
closest_to(roadNetwork.vertices,person);;;;;;
roadNetwork.vertices;;;;;;
set location value: point(personIntersection) ;;;;;;
point(personIntersection);;;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;;;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);;;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;;;;;;
numAutonomousBikes + 1;;;;;;
set available value: autonomousBike where (each.availableForRideAB()) ;9709;7431;;;;
autonomousBike where (each.availableForRideAB());9683;7431;;;;
each.availableForRideAB();;;;;;
if empty(available) and dynamicFleetsizing ;1825;7431;;;;
empty(available) and dynamicFleetsizing;7;7431;;;;
empty(available);4;7431;;;;
else ;1812;7431;;;;
if person != nil ;1802;7431;;;;
person != nil;4;7431;;;;
else ;1240;5067;;;;
if pack != nil ;1237;5067;;;;
pack != nil;4;5067;;;;
else ;;;;;;
write 'Error in request bike' ;;;;;;
return false ;;;;;;
let packIntersection type: point value: closest_to(roadNetwork.vertices,pack) ;236;5067;;;;
closest_to(roadNetwork.vertices,pack);228;5067;;;;
roadNetwork.vertices;24;5067;;;;
let b type: autonomousBike value: closest_to(available,packIntersection) ;249;5067;;;;
closest_to(available,packIntersection);239;5067;;;;
let d type: float value: self.distanceInGraph(origin:packIntersection, destination:b.location) ;568;5067;;;;
self.distanceInGraph(origin:packIntersection, destination:b.location);;;;;;
b.location;;;;;;
if (d > pack.dynamic_maxDistancePackage) and dynamicFleetsizing ;45;5067;;;;
(d > pack.dynamic_maxDistancePackage) and dynamicFleetsizing;18;5067;;;;
d > pack.dynamic_maxDistancePackage;16;5067;;;;
pack.dynamic_maxDistancePackage;10;5067;;;;
else ;17;5060;;;;
if (d > pack.dynamic_maxDistancePackage) and !dynamicFleetsizing ;11;5060;;;;
(d > pack.dynamic_maxDistancePackage) and !dynamicFleetsizing;10;5060;;;;
d > pack.dynamic_maxDistancePackage;7;5060;;;;
pack.dynamic_maxDistancePackage;4;5060;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;8;14;;;;
write pack.my_cell.name ;3;7;;;;
pack.my_cell.name;0;7;;;;
pack.my_cell;0;7;;;;
set location value: point(packIntersection) ;0;7;;;;
point(packIntersection);0;7;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;0;7;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);0;7;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;0;7;;;;
numAutonomousBikes + 1;0;7;;;;
set b value: last(autonomousBike.population) ;0;7;;;;
last(autonomousBike.population);0;7;;;;
autonomousBike.population;0;7;;;;
let d2 type: float value: self.distanceInGraph(origin:packIntersection, destination:b.location) ;0;7;;;;
self.distanceInGraph(origin:packIntersection, destination:b.location);;;;;;
b.location;;;;;;
if d2 > pack.dynamic_maxDistancePackage ;0;7;;;;
d2 > pack.dynamic_maxDistancePackage;0;7;;;;
pack.dynamic_maxDistancePackage;0;7;;;;
write 'ERROR IN +1 BIKE' ;;;;;;
return false ;;;;;;
ask b ;149;10134;;;;
do pickUp (person:nil, pack:pack);66;5067;;;;
self.pickUp(person:nil, pack:pack);;;;;;
ask pack ;82;10134;;;;
do deliver (ab:b);34;5067;;;;
self.deliver(ab:b);;;;;;
return true ;0;5067;;;;
let personIntersection type: point value: closest_to(roadNetwork.vertices,person) ;117;2364;;;;
closest_to(roadNetwork.vertices,person);114;2364;;;;
roadNetwork.vertices;4;2364;;;;
let b type: autonomousBike value: closest_to(available,personIntersection) ;94;2364;;;;
closest_to(available,personIntersection);93;2364;;;;
let d type: float value: self.distanceInGraph(origin:personIntersection, destination:b.location) ;238;2364;;;;
self.distanceInGraph(origin:personIntersection, destination:b.location);;;;;;
b.location;;;;;;
if (d > person.dynamic_maxDistancePeople) and dynamicFleetsizing ;31;2364;;;;
(d > person.dynamic_maxDistancePeople) and dynamicFleetsizing;6;2364;;;;
d > person.dynamic_maxDistancePeople;5;2364;;;;
person.dynamic_maxDistancePeople;3;2364;;;;
else ;7;2348;;;;
if (d > person.dynamic_maxDistancePeople) and !dynamicFleetsizing ;6;2348;;;;
(d > person.dynamic_maxDistancePeople) and !dynamicFleetsizing;4;2348;;;;
d > person.dynamic_maxDistancePeople;4;2348;;;;
person.dynamic_maxDistancePeople;1;2348;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;10;32;;;;
write person.my_cell.name ;4;16;;;;
person.my_cell.name;0;16;;;;
person.my_cell;0;16;;;;
set location value: point(personIntersection) ;0;16;;;;
point(personIntersection);0;16;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;0;16;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);0;16;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;0;16;;;;
numAutonomousBikes + 1;0;16;;;;
set b value: last(autonomousBike.population) ;0;16;;;;
last(autonomousBike.population);0;16;;;;
autonomousBike.population;0;16;;;;
let d2 type: float value: self.distanceInGraph(origin:personIntersection, destination:b.location) ;5;16;;;;
self.distanceInGraph(origin:personIntersection, destination:b.location);;;;;;
b.location;;;;;;
if d2 > person.dynamic_maxDistancePeople ;0;16;;;;
d2 > person.dynamic_maxDistancePeople;0;16;;;;
person.dynamic_maxDistancePeople;0;16;;;;
write 'ERROR IN +1 BIKE' ;;;;;;
return false ;;;;;;
ask b ;68;4728;;;;
do pickUp (person:person, pack:nil);31;2364;;;;
self.pickUp(person:person, pack:nil);;;;;;
ask person ;40;4728;;;;
do ride (ab:b);16;2364;;;;
self.ride(ab:b);;;;;;
return true ;1;2364;;;;
write 'ERROR, still empty' ;;;;;;
return false ;;;;;;
bool bidForBike (people person, package pack);;;;;;
arg person type: people ;;;;;;
arg pack type: package ;;;;;;
let availableBikes type: list<autonomousBike> value: autonomousBike where (each.availableForRideAB()) ;;;;;;
autonomousBike where (each.availableForRideAB());;;;;;
each.availableForRideAB();;;;;;
if empty(availableBikes) and dynamicFleetsizing ;;;;;;
empty(availableBikes) and dynamicFleetsizing;;;;;;
empty(availableBikes);;;;;;
else ;;;;;;
if empty(availableBikes) and !dynamicFleetsizing ;;;;;;
empty(availableBikes) and !dynamicFleetsizing;;;;;;
empty(availableBikes);;;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;;;;;;
if person != nil ;;;;;;
person != nil;;;;;;
else ;;;;;;
if pack != nil ;;;;;;
pack != nil;;;;;;
write pack.my_cell.name ;;;;;;
pack.my_cell.name;;;;;;
pack.my_cell;;;;;;
let packIntersection type: point value: closest_to(roadNetwork.vertices,pack) ;;;;;;
closest_to(roadNetwork.vertices,pack);;;;;;
roadNetwork.vertices;;;;;;
set location value: point(packIntersection) ;;;;;;
point(packIntersection);;;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;;;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);;;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;;;;;;
numAutonomousBikes + 1;;;;;;
write person.my_cell.name ;;;;;;
person.my_cell.name;;;;;;
person.my_cell;;;;;;
let personIntersection type: point value: closest_to(roadNetwork.vertices,person) ;;;;;;
closest_to(roadNetwork.vertices,person);;;;;;
roadNetwork.vertices;;;;;;
set location value: point(personIntersection) ;;;;;;
point(personIntersection);;;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;;;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);;;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;;;;;;
numAutonomousBikes + 1;;;;;;
set availableBikes value: autonomousBike where (each.availableForRideAB()) ;;;;;;
autonomousBike where (each.availableForRideAB());;;;;;
each.availableForRideAB();;;;;;
if empty(availableBikes) and dynamicFleetsizing ;;;;;;
empty(availableBikes) and dynamicFleetsizing;;;;;;
empty(availableBikes);;;;;;
else ;;;;;;
if person != nil ;;;;;;
person != nil;;;;;;
else ;;;;;;
if pack != nil ;;;;;;
pack != nil;;;;;;
else ;;;;;;
write 'ERROR in bidForBike caller' ;;;;;;
return false ;;;;;;
let packIntersection type: point value: closest_to(roadNetwork.vertices,pack) ;;;;;;
closest_to(roadNetwork.vertices,pack);;;;;;
roadNetwork.vertices;;;;;;
let b type: autonomousBike value: closest_to(availableBikes,packIntersection) ;;;;;;
closest_to(availableBikes,packIntersection);;;;;;
let d type: float value: self.distanceInGraph(origin:packIntersection, destination:b.location) ;;;;;;
self.distanceInGraph(origin:packIntersection, destination:b.location);;;;;;
b.location;;;;;;
if (d > pack.dynamic_maxDistancePackage) and dynamicFleetsizing ;;;;;;
(d > pack.dynamic_maxDistancePackage) and dynamicFleetsizing;;;;;;
d > pack.dynamic_maxDistancePackage;;;;;;
pack.dynamic_maxDistancePackage;;;;;;
else ;;;;;;
if (d > pack.dynamic_maxDistancePackage) and !dynamicFleetsizing ;;;;;;
(d > pack.dynamic_maxDistancePackage) and !dynamicFleetsizing;;;;;;
d > pack.dynamic_maxDistancePackage;;;;;;
pack.dynamic_maxDistancePackage;;;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;;;;;;
write pack.my_cell.name ;;;;;;
pack.my_cell.name;;;;;;
pack.my_cell;;;;;;
set location value: point(packIntersection) ;;;;;;
point(packIntersection);;;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;;;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);;;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;;;;;;
numAutonomousBikes + 1;;;;;;
set b value: last(autonomousBike.population) ;;;;;;
last(autonomousBike.population);;;;;;
autonomousBike.population;;;;;;
let d2 type: float value: self.distanceInGraph(origin:packIntersection, destination:b.location) ;;;;;;
self.distanceInGraph(origin:packIntersection, destination:b.location);;;;;;
b.location;;;;;;
if d2 > pack.dynamic_maxDistancePackage ;;;;;;
d2 > pack.dynamic_maxDistancePackage;;;;;;
pack.dynamic_maxDistancePackage;;;;;;
write 'ERROR IN +1 BIKE' ;;;;;;
return false ;;;;;;
let bidValuePackage type: float value: pack_bid_ct * ((-pack_bid_dist_coef * d) + (pack_bid_queue_coef * pack.queueTime)) ;;;;;;
pack_bid_ct * ((-pack_bid_dist_coef * d) + (pack_bid_queue_coef * pack.queueTime));;;;;;
(-pack_bid_dist_coef * d) + (pack_bid_queue_coef * pack.queueTime);;;;;;
-pack_bid_dist_coef * d;;;;;;
-pack_bid_dist_coef;;;;;;
pack_bid_queue_coef * pack.queueTime;;;;;;
pack.queueTime;;;;;;
ask b ;;;;;;
do receiveBid (person:nil, pack:pack, bidValue:bidValuePackage);;;;;;
self.receiveBid(person:nil, pack:pack, bidValue:bidValuePackage);;;;;;
return true ;;;;;;
let personIntersection type: point value: closest_to(roadNetwork.vertices,person) ;;;;;;
closest_to(roadNetwork.vertices,person);;;;;;
roadNetwork.vertices;;;;;;
let b type: autonomousBike value: closest_to(availableBikes,personIntersection) ;;;;;;
closest_to(availableBikes,personIntersection);;;;;;
let d type: float value: self.distanceInGraph(origin:personIntersection, destination:b.location) ;;;;;;
self.distanceInGraph(origin:personIntersection, destination:b.location);;;;;;
b.location;;;;;;
if (d > person.dynamic_maxDistancePeople) and dynamicFleetsizing ;;;;;;
(d > person.dynamic_maxDistancePeople) and dynamicFleetsizing;;;;;;
d > person.dynamic_maxDistancePeople;;;;;;
person.dynamic_maxDistancePeople;;;;;;
else ;;;;;;
if (d > person.dynamic_maxDistancePeople) and !dynamicFleetsizing ;;;;;;
(d > person.dynamic_maxDistancePeople) and !dynamicFleetsizing;;;;;;
d > person.dynamic_maxDistancePeople;;;;;;
person.dynamic_maxDistancePeople;;;;;;
!dynamicFleetsizing;;;;;;
return false ;;;;;;
create autonomousBike number: 1 ;;;;;;
write person.my_cell.name ;;;;;;
person.my_cell.name;;;;;;
person.my_cell;;;;;;
set location value: point(personIntersection) ;;;;;;
point(personIntersection);;;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;;;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);;;;;;
set numAutonomousBikes value: numAutonomousBikes + 1 ;;;;;;
numAutonomousBikes + 1;;;;;;
set b value: last(autonomousBike.population) ;;;;;;
last(autonomousBike.population);;;;;;
autonomousBike.population;;;;;;
let d2 type: float value: self.distanceInGraph(origin:personIntersection, destination:b.location) ;;;;;;
self.distanceInGraph(origin:personIntersection, destination:b.location);;;;;;
b.location;;;;;;
if d2 > person.dynamic_maxDistancePeople ;;;;;;
d2 > person.dynamic_maxDistancePeople;;;;;;
person.dynamic_maxDistancePeople;;;;;;
write 'ERROR IN +1 BIKE' ;;;;;;
return false ;;;;;;
let bidValuePerson type: float value: person_bid_ct * ((-person_bid_dist_coef * d) + (person_bid_queue_coef * person.queueTime)) ;;;;;;
person_bid_ct * ((-person_bid_dist_coef * d) + (person_bid_queue_coef * person.queueTime));;;;;;
(-person_bid_dist_coef * d) + (person_bid_queue_coef * person.queueTime);;;;;;
-person_bid_dist_coef * d;;;;;;
-person_bid_dist_coef;;;;;;
person_bid_queue_coef * person.queueTime;;;;;;
person.queueTime;;;;;;
ask b ;;;;;;
do receiveBid (person:person, pack:nil, bidValue:bidValuePerson);;;;;;
self.receiveBid(person:person, pack:nil, bidValue:bidValuePerson);;;;;;
return true ;;;;;;
write 'ERROR: STILL no bikes available' ;;;;;;
return false ;;;;;;
bool bikeAssigned (people person, package pack);;;;;;
arg person type: people ;;;;;;
arg pack type: package ;;;;;;
if person != nil ;;;;;;
person != nil;;;;;;
else ;;;;;;
if pack != nil ;;;;;;
pack != nil;;;;;;
else ;;;;;;
return false ;;;;;;
if pack.autonomousBikeToDeliver != nil ;;;;;;
pack.autonomousBikeToDeliver != nil;;;;;;
pack.autonomousBikeToDeliver;;;;;;
else ;;;;;;
return false ;;;;;;
return true ;;;;;;
if person.autonomousBikeToRide != nil ;;;;;;
person.autonomousBikeToRide != nil;;;;;;
person.autonomousBikeToRide;;;;;;
else ;;;;;;
return false ;;;;;;
return true ;;;;;;
species Logger ;0;2881;;;;
main_model host ;;;;;;
-29;;;;;;
list<Logger> peers ;;;;;;
-199;;;;;;
string filename ;;;;;;
list<string> columns ;;;;;;
agent loggingAgent ;16;89547;;;;
bool logPredicate ;;;;;;
action log (list data);4529;8742;;;;
arg data type: list ;1;8742;;;;
if self.logPredicate() ;4457;8742;;;;
self.logPredicate();;;;;;
ask host ;8847;15516;;;;
do log (filename:myself.filename, data:([string(myself.loggingAgent.name)]) + data, columns:myself.columns);4408;7758;;;;
self.log(filename:myself.filename, data:([string(myself.loggingAgent.name)]) + data, columns:myself.columns);;;;;;
myself.filename;;;;;;
([string(myself.loggingAgent.name)]) + data;;;;;;
[string(myself.loggingAgent.name)];;;;;;
string(myself.loggingAgent.name);;;;;;
myself.loggingAgent.name;;;;;;
myself.loggingAgent;;;;;;
myself.columns;;;;;;
species peopleLogger_trip parent: Logger mirrors: people ;16165;2881;;;;
main_model host ;4;14216;;;;
-29;;;;;;
list<peopleLogger_trip> peers ;2;14216;;;;
-199;;;;;;
string filename <- string((((('people_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second)) ;46;14216;;;;
string((((('people_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second));38;14216;;;;
(((('people_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);32;14216;;;;
((('people_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';25;14216;;;;
(('people_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute);20;14216;;;;
('people_trips_' + string(nowDate.hour)) + '_';12;14216;;;;
'people_trips_' + string(nowDate.hour);10;14216;;;;
string(nowDate.hour);6;14216;;;;
nowDate.hour;2;14216;;;;
string(nowDate.minute);4;14216;;;;
nowDate.minute;2;14216;;;;
string(nowDate.second);2;14216;;;;
nowDate.second;1;14216;;;;
list<string> columns <- ['Trip Served','Wait Time (min)','Departure Time','Arrival Time','Duration (min)','Origin [lat]','Origin [lon]','Destination [lat]','Destination [lon]','Distance (m)'] ;15;14216;;;;
['Trip Served','Wait Time (min)','Departure Time','Arrival Time','Duration (min)','Origin [lat]','Origin [lon]','Destination [lat]','Destination [lon]','Distance (m)'];11;14216;;;;
people persontarget ;6;14216;;;;
people target ;6;14216;;;;
-28;;;;;;
bool logPredicate ;4;2363;;;;
return peopleTripLog ;0;2363;;;;
action logTrip (bool served, float waitTime, date departure, date arrival, float tripduration, point origin, point destination, float distance);1839;2363;;;;
arg served type: bool ;0;2363;;;;
arg waitTime type: float ;0;2363;;;;
arg departure type: date ;0;2363;;;;
arg arrival type: date ;1;2363;;;;
arg tripduration type: float ;0;2363;;;;
arg origin type: point ;0;2363;;;;
arg destination type: point ;0;2363;;;;
arg distance type: float ;0;2363;;;;
let origin_WGS84 type: point value: CRS_transform(origin,'EPSG:4326').location ;266;2363;;;;
CRS_transform(origin,'EPSG:4326').location;265;2363;;;;
CRS_transform(origin,'EPSG:4326');264;2363;;;;
let destination_WGS84 type: point value: CRS_transform(destination,'EPSG:4326').location ;52;2363;;;;
CRS_transform(destination,'EPSG:4326').location;48;2363;;;;
CRS_transform(destination,'EPSG:4326');46;2363;;;;
let dep type: string ;5;2363;;;;
let des type: string ;0;2363;;;;
if departure = nil ;16;2363;;;;
departure = nil;3;2363;;;;
else ;11;2363;;;;
set dep value: string(departure,'HH:mm:ss') ;9;2363;;;;
string(departure,'HH:mm:ss');8;2363;;;;
set dep value: nil ;;;;;;
if arrival = nil ;3;2363;;;;
arrival = nil;0;2363;;;;
else ;2;2363;;;;
set des value: string(arrival,'HH:mm:ss') ;2;2363;;;;
string(arrival,'HH:mm:ss');0;2363;;;;
set des value: nil ;;;;;;
do log (data:[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance]);1438;2363;;;;
self.log(data:[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance]);;;;;;
[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance];;;;;;
origin_WGS84.x;;;;;;
origin_WGS84.y;;;;;;
destination_WGS84.x;;;;;;
destination_WGS84.y;;;;;;
init ;33;14216;;;;
set persontarget value: people(target) ;15;14216;;;;
people(target);9;14216;;;;
set persontarget.tripLogger value: self ;11;14216;;;;
persontarget.tripLogger;;;;;;
set loggingAgent value: persontarget ;3;14216;;;;
species packageLogger_trip parent: Logger mirrors: package ;37161;2881;;;;
main_model host ;3;30079;;;;
-29;;;;;;
list<packageLogger_trip> peers ;11;30079;;;;
-199;;;;;;
string filename <- string((((('package_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second)) ;116;30079;;;;
string((((('package_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second));95;30079;;;;
(((('package_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);90;30079;;;;
((('package_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';64;30079;;;;
(('package_trips_' + string(nowDate.hour)) + '_') + string(nowDate.minute);56;30079;;;;
('package_trips_' + string(nowDate.hour)) + '_';37;30079;;;;
'package_trips_' + string(nowDate.hour);28;30079;;;;
string(nowDate.hour);24;30079;;;;
nowDate.hour;13;30079;;;;
string(nowDate.minute);15;30079;;;;
nowDate.minute;7;30079;;;;
string(nowDate.second);14;30079;;;;
nowDate.second;5;30079;;;;
list<string> columns <- ['Trip Served','Wait Time (min)','Departure Time','Arrival Time','Duration (min)','Origin [lat]','Origin [lon]','Destination [lat]','Destination [lon]','Distance (m)'] ;51;30079;;;;
['Trip Served','Wait Time (min)','Departure Time','Arrival Time','Duration (min)','Origin [lat]','Origin [lon]','Destination [lat]','Destination [lon]','Distance (m)'];39;30079;;;;
package packagetarget ;1;30079;;;;
package target ;20;30079;;;;
-28;;;;;;
bool logPredicate ;18;5067;;;;
return packageTripLog ;5;5067;;;;
action logTrip (bool served, float waitTime, date departure, date arrival, float tripduration, point origin, point destination, float distance);3725;5067;;;;
arg served type: bool ;1;5067;;;;
arg waitTime type: float ;0;5067;;;;
arg departure type: date ;1;5067;;;;
arg arrival type: date ;0;5067;;;;
arg tripduration type: float ;1;5067;;;;
arg origin type: point ;1;5067;;;;
arg destination type: point ;0;5067;;;;
arg distance type: float ;0;5067;;;;
let origin_WGS84 type: point value: CRS_transform(origin,'EPSG:4326').location ;364;5067;;;;
CRS_transform(origin,'EPSG:4326').location;358;5067;;;;
CRS_transform(origin,'EPSG:4326');356;5067;;;;
let destination_WGS84 type: point value: CRS_transform(destination,'EPSG:4326').location ;218;5067;;;;
CRS_transform(destination,'EPSG:4326').location;212;5067;;;;
CRS_transform(destination,'EPSG:4326');209;5067;;;;
let dep type: string ;3;5067;;;;
let des type: string ;0;5067;;;;
if departure = nil ;41;5067;;;;
departure = nil;3;5067;;;;
else ;33;5067;;;;
set dep value: string(departure,'HH:mm:ss') ;30;5067;;;;
string(departure,'HH:mm:ss');18;5067;;;;
set dep value: nil ;;;;;;
if arrival = nil ;18;5067;;;;
arrival = nil;4;5067;;;;
else ;9;5067;;;;
set des value: string(arrival,'HH:mm:ss') ;6;5067;;;;
string(arrival,'HH:mm:ss');2;5067;;;;
set des value: nil ;;;;;;
do log (data:[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance]);2907;5067;;;;
self.log(data:[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance]);;;;;;
[served,waitTime,dep,des,tripduration,origin_WGS84.x,origin_WGS84.y,destination_WGS84.x,destination_WGS84.y,distance];;;;;;
origin_WGS84.x;;;;;;
origin_WGS84.y;;;;;;
destination_WGS84.x;;;;;;
destination_WGS84.y;;;;;;
init ;94;30079;;;;
set packagetarget value: package(target) ;39;30079;;;;
package(target);30;30079;;;;
set packagetarget.tripLogger value: self ;24;30079;;;;
packagetarget.tripLogger;;;;;;
set loggingAgent value: packagetarget ;18;30079;;;;
species peopleLogger parent: Logger mirrors: people ;16359;2881;;;;
main_model host ;2;14216;;;;
-29;;;;;;
list<peopleLogger> peers ;1;14216;;;;
-199;;;;;;
string filename <- (((('people_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second) ;53;14216;;;;
(((('people_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);44;14216;;;;
((('people_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';30;14216;;;;
(('people_event' + string(nowDate.hour)) + '_') + string(nowDate.minute);25;14216;;;;
('people_event' + string(nowDate.hour)) + '_';9;14216;;;;
'people_event' + string(nowDate.hour);8;14216;;;;
string(nowDate.hour);6;14216;;;;
nowDate.hour;5;14216;;;;
string(nowDate.minute);8;14216;;;;
nowDate.minute;5;14216;;;;
string(nowDate.second);7;14216;;;;
nowDate.second;5;14216;;;;
list<string> columns <- ['Event','Message','Start Time','End Time','Duration (min)','Distance (m)'] ;15;14216;;;;
['Event','Message','Start Time','End Time','Duration (min)','Distance (m)'];12;14216;;;;
people persontarget ;3;14216;;;;
date departureTime ;4;14216;;;;
int departureCycle ;2;14216;;;;
int cycleAutonomousBikeRequested ;3;14216;;;;
float waitTime ;4;14216;;;;
int cycleStartActivity ;2;14216;;;;
date timeStartActivity ;2;14216;;;;
point locationStartActivity ;2;14216;;;;
string currentState ;2;14216;;;;
bool served ;4;14216;;;;
string timeStartstr ;1;14216;;;;
string currentstr ;1;14216;;;;
people target ;2;14216;;;;
-28;;;;;;
bool logPredicate ;;;;;;
return peopleEventLog ;;;;;;
action logEnterState (string logmessage);2220;28398;;;;
arg logmessage type: string ;2;28398;;;;
set cycleStartActivity value: cycle ;35;28398;;;;
set timeStartActivity value: current_date ;22;28398;;;;
set locationStartActivity value: persontarget.location ;37;28398;;;;
persontarget.location;20;28398;;;;
set currentState value: persontarget.state ;35;28398;;;;
persontarget.state;14;28398;;;;
if peopleEventLog ;9;28398;;;;
do log (data:(['START: ' + currentState]) + ([logmessage]));;;;;;
self.log(data:(['START: ' + currentState]) + ([logmessage]));;;;;;
(['START: ' + currentState]) + ([logmessage]);;;;;;
['START: ' + currentState];;;;;;
'START: ' + currentState;;;;;;
[logmessage];;;;;;
if peopleTripLog ;1962;28398;;;;
switch currentState ;1945;28398;;;;
match 'requestingAutonomousBike' ;9;2364;;;;
set cycleAutonomousBikeRequested value: cycle ;2;2364;;;;
set served value: false ;4;2364;;;;
match 'requested_with_bid' ;;;;;;
set cycleAutonomousBikeRequested value: cycle ;;;;;;
set served value: false ;;;;;;
match 'riding_autonomousBike' ;15;2364;;;;
set waitTime value: ((cycle * step) - (cycleAutonomousBikeRequested * step)) / 60 ;5;2364;;;;
((cycle * step) - (cycleAutonomousBikeRequested * step)) / 60;4;2364;;;;
(cycle * step) - (cycleAutonomousBikeRequested * step);3;2364;;;;
cycle * step;1;2364;;;;
cycleAutonomousBikeRequested * step;1;2364;;;;
set departureTime value: current_date ;2;2364;;;;
set departureCycle value: cycle ;2;2364;;;;
set served value: true ;2;2364;;;;
match 'wandering' ;1901;16579;;;;
if float(cycle) != 0 ;1897;16579;;;;
float(cycle) != 0;21;16579;;;;
float(cycle);14;16579;;;;
ask persontarget.tripLogger ;3728;4726;;;;
persontarget.tripLogger;4;2363;;;;
do logTrip (served:myself.served, waitTime:myself.waitTime, departure:myself.departureTime, arrival:current_date, tripduration:((cycle * step) - (myself.departureCycle * step)) / 60, origin:persontarget.start_point.location, destination:persontarget.target_point.location, distance:persontarget.tripdistance);1859;2363;;;;
self.logTrip(served:myself.served, waitTime:myself.waitTime, departure:myself.departureTime, arrival:current_date, tripduration:((cycle * step) - (myself.departureCycle * step)) / 60, origin:persontarget.start_point.location, destination:persontarget.target_point.location, distance:persontarget.tripdistance);;;;;;
myself.served;;;;;;
myself.waitTime;;;;;;
myself.departureTime;;;;;;
((cycle * step) - (myself.departureCycle * step)) / 60;;;;;;
(cycle * step) - (myself.departureCycle * step);;;;;;
cycle * step;;;;;;
myself.departureCycle * step;;;;;;
myself.departureCycle;;;;;;
persontarget.start_point.location;;;;;;
persontarget.start_point;;;;;;
persontarget.target_point.location;;;;;;
persontarget.target_point;;;;;;
persontarget.tripdistance;;;;;;
action logExitState (string logmessage);;;;;;
arg logmessage type: string ;;;;;;
if timeStartActivity = nil ;;;;;;
timeStartActivity = nil;;;;;;
else ;;;;;;
set timeStartstr value: string(timeStartActivity,'HH:mm:ss') ;;;;;;
string(timeStartActivity,'HH:mm:ss');;;;;;
set timeStartstr value: nil ;;;;;;
if current_date = nil ;;;;;;
current_date = nil;;;;;;
else ;;;;;;
set currentstr value: string(current_date,'HH:mm:ss') ;;;;;;
string(current_date,'HH:mm:ss');;;;;;
set currentstr value: nil ;;;;;;
do log (data:['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:persontarget.location)]);;;;;;
self.log(data:['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:persontarget.location)]);;;;;;
['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:persontarget.location)];;;;;;
'END: ' + currentState;;;;;;
((cycle * step) - (cycleStartActivity * step)) / 60;;;;;;
(cycle * step) - (cycleStartActivity * step);;;;;;
cycle * step;;;;;;
cycleStartActivity * step;;;;;;
host.distanceInGraph(origin:locationStartActivity, destination:persontarget.location);;;;;;
persontarget.location;;;;;;
action logEvent (string event);;;;;;
arg event type: string ;;;;;;
do log (data:[event]);;;;;;
self.log(data:[event]);;;;;;
[event];;;;;;
init ;37;14216;;;;
set persontarget value: people(target) ;13;14216;;;;
people(target);7;14216;;;;
set persontarget.logger value: self ;16;14216;;;;
persontarget.logger;;;;;;
set loggingAgent value: persontarget ;7;14216;;;;
species packageLogger parent: Logger mirrors: package ;37064;2881;;;;
main_model host ;1;30079;;;;
-29;;;;;;
list<packageLogger> peers ;4;30079;;;;
-199;;;;;;
string filename <- (((('package_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second) ;90;30079;;;;
(((('package_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);71;30079;;;;
((('package_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';52;30079;;;;
(('package_event' + string(nowDate.hour)) + '_') + string(nowDate.minute);47;30079;;;;
('package_event' + string(nowDate.hour)) + '_';37;30079;;;;
'package_event' + string(nowDate.hour);32;30079;;;;
string(nowDate.hour);29;30079;;;;
nowDate.hour;15;30079;;;;
string(nowDate.minute);8;30079;;;;
nowDate.minute;4;30079;;;;
string(nowDate.second);11;30079;;;;
nowDate.second;4;30079;;;;
list<string> columns <- ['Event','Message','Start Time','End Time','Duration (min)','Distance (m)'] ;38;30079;;;;
['Event','Message','Start Time','End Time','Duration (min)','Distance (m)'];24;30079;;;;
package packagetarget ;2;30079;;;;
date departureTime ;0;30079;;;;
int departureCycle ;1;30079;;;;
int cycleRequestingAutonomousBike ;3;30079;;;;
float waitTime ;6;30079;;;;
int cycleStartActivity ;5;30079;;;;
date timeStartActivity ;6;30079;;;;
point locationStartActivity ;3;30079;;;;
string currentState ;7;30079;;;;
bool served <- false ;13;30079;;;;
string timeStartstr ;3;30079;;;;
string currentstr ;8;30079;;;;
package target ;26;30079;;;;
-28;;;;;;
bool logPredicate ;;;;;;
return packageEventLog ;;;;;;
action logEnterState (string logmessage);4401;60481;;;;
arg logmessage type: string ;5;60481;;;;
set cycleStartActivity value: cycle ;53;60481;;;;
set timeStartActivity value: current_date ;38;60481;;;;
set locationStartActivity value: packagetarget.location ;61;60481;;;;
packagetarget.location;38;60481;;;;
set currentState value: packagetarget.state ;68;60481;;;;
packagetarget.state;34;60481;;;;
if packageEventLog ;19;60481;;;;
do log (data:(['START: ' + currentState]) + ([logmessage]));;;;;;
self.log(data:(['START: ' + currentState]) + ([logmessage]));;;;;;
(['START: ' + currentState]) + ([logmessage]);;;;;;
['START: ' + currentState];;;;;;
'START: ' + currentState;;;;;;
[logmessage];;;;;;
if packageTripLog ;3938;60481;;;;
switch currentState ;3897;60481;;;;
match 'requestingAutonomousBike' ;15;5067;;;;
set cycleRequestingAutonomousBike value: cycle ;2;5067;;;;
set served value: false ;5;5067;;;;
match 'requested_with_bid' ;;;;;;
set cycleRequestingAutonomousBike value: cycle ;;;;;;
set served value: false ;;;;;;
match 'delivering_autonomousBike' ;32;5067;;;;
set waitTime value: ((cycle * step) - (cycleRequestingAutonomousBike * step)) / 60 ;23;5067;;;;
((cycle * step) - (cycleRequestingAutonomousBike * step)) / 60;20;5067;;;;
(cycle * step) - (cycleRequestingAutonomousBike * step);14;5067;;;;
cycle * step;8;5067;;;;
cycleRequestingAutonomousBike * step;3;5067;;;;
set departureTime value: current_date ;3;5067;;;;
set departureCycle value: cycle ;1;5067;;;;
set served value: true ;0;5067;;;;
match 'delivered' ;3807;5067;;;;
if float(cycle) != 0 ;3803;5067;;;;
float(cycle) != 0;8;5067;;;;
float(cycle);3;5067;;;;
ask packagetarget.tripLogger ;7569;10134;;;;
packagetarget.tripLogger;7;5067;;;;
do logTrip (served:myself.served, waitTime:myself.waitTime, departure:myself.departureTime, arrival:current_date, tripduration:((cycle * step) - (myself.departureCycle * step)) / 60, origin:packagetarget.start_point.location, destination:packagetarget.target_point.location, distance:packagetarget.tripdistance);3767;5067;;;;
self.logTrip(served:myself.served, waitTime:myself.waitTime, departure:myself.departureTime, arrival:current_date, tripduration:((cycle * step) - (myself.departureCycle * step)) / 60, origin:packagetarget.start_point.location, destination:packagetarget.target_point.location, distance:packagetarget.tripdistance);;;;;;
myself.served;;;;;;
myself.waitTime;;;;;;
myself.departureTime;;;;;;
((cycle * step) - (myself.departureCycle * step)) / 60;;;;;;
(cycle * step) - (myself.departureCycle * step);;;;;;
cycle * step;;;;;;
myself.departureCycle * step;;;;;;
myself.departureCycle;;;;;;
packagetarget.start_point.location;;;;;;
packagetarget.start_point;;;;;;
packagetarget.target_point.location;;;;;;
packagetarget.target_point;;;;;;
packagetarget.tripdistance;;;;;;
action logExitState (string logmessage);;;;;;
arg logmessage type: string ;;;;;;
if timeStartActivity = nil ;;;;;;
timeStartActivity = nil;;;;;;
else ;;;;;;
set timeStartstr value: string(timeStartActivity,'HH:mm:ss') ;;;;;;
string(timeStartActivity,'HH:mm:ss');;;;;;
set timeStartstr value: nil ;;;;;;
if current_date = nil ;;;;;;
current_date = nil;;;;;;
else ;;;;;;
set currentstr value: string(current_date,'HH:mm:ss') ;;;;;;
string(current_date,'HH:mm:ss');;;;;;
set currentstr value: nil ;;;;;;
do log (data:['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:packagetarget.location)]);;;;;;
self.log(data:['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:packagetarget.location)]);;;;;;
['END: ' + currentState,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,host.distanceInGraph(origin:locationStartActivity, destination:packagetarget.location)];;;;;;
'END: ' + currentState;;;;;;
((cycle * step) - (cycleStartActivity * step)) / 60;;;;;;
(cycle * step) - (cycleStartActivity * step);;;;;;
cycle * step;;;;;;
cycleStartActivity * step;;;;;;
host.distanceInGraph(origin:locationStartActivity, destination:packagetarget.location);;;;;;
packagetarget.location;;;;;;
action logEvent (string event);;;;;;
arg event type: string ;;;;;;
do log (data:[event]);;;;;;
self.log(data:[event]);;;;;;
[event];;;;;;
init ;82;30079;;;;
set packagetarget value: package(target) ;37;30079;;;;
package(target);25;30079;;;;
set packagetarget.logger value: self ;17;30079;;;;
packagetarget.logger;;;;;;
set loggingAgent value: packagetarget ;8;30079;;;;
species autonomousBikeLogger_chargeEvents parent: Logger mirrors: autonomousBike ;253;2881;;;;
main_model host ;0;319;;;;
-29;;;;;;
list<autonomousBikeLogger_chargeEvents> peers ;0;319;;;;
-199;;;;;;
string filename <- (((('AutonomousBike_station_charge' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second) ;1;319;;;;
(((('AutonomousBike_station_charge' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);1;319;;;;
((('AutonomousBike_station_charge' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';1;319;;;;
(('AutonomousBike_station_charge' + string(nowDate.hour)) + '_') + string(nowDate.minute);1;319;;;;
('AutonomousBike_station_charge' + string(nowDate.hour)) + '_';1;319;;;;
'AutonomousBike_station_charge' + string(nowDate.hour);1;319;;;;
string(nowDate.hour);0;319;;;;
nowDate.hour;0;319;;;;
string(nowDate.minute);0;319;;;;
nowDate.minute;0;319;;;;
string(nowDate.second);0;319;;;;
nowDate.second;0;319;;;;
list<string> columns <- ['Station','Start Time','End Time','Duration (min)','Start Battery %','End Battery %','Battery Gain %'] ;0;319;;;;
['Station','Start Time','End Time','Duration (min)','Start Battery %','End Battery %','Battery Gain %'];0;319;;;;
autonomousBike autonomousBiketarget ;0;319;;;;
string startstr ;0;319;;;;
string endstr ;0;319;;;;
autonomousBike target ;0;319;;;;
-28;;;;;;
bool logPredicate ;0;328;;;;
return stationChargeLogs ;0;328;;;;
action logCharge (chargingStation station, date startTime, date endTime, float chargeDuration, float startBattery, float endBattery, float batteryGain);275;328;;;;
arg station type: chargingStation ;0;328;;;;
arg startTime type: date ;0;328;;;;
arg endTime type: date ;0;328;;;;
arg chargeDuration type: float ;0;328;;;;
arg startBattery type: float ;0;328;;;;
arg endBattery type: float ;0;328;;;;
arg batteryGain type: float ;0;328;;;;
if startTime = nil ;2;328;;;;
startTime = nil;1;328;;;;
else ;1;328;;;;
set startstr value: string(startTime,'HH:mm:ss') ;1;328;;;;
string(startTime,'HH:mm:ss');0;328;;;;
set startstr value: nil ;;;;;;
if endTime = nil ;1;328;;;;
endTime = nil;0;328;;;;
else ;1;328;;;;
set endstr value: string(endTime,'HH:mm:ss') ;1;328;;;;
string(endTime,'HH:mm:ss');0;328;;;;
set endstr value: nil ;;;;;;
do log (data:[station,startstr,endstr,chargeDuration,startBattery,endBattery,batteryGain]);266;328;;;;
self.log(data:[station,startstr,endstr,chargeDuration,startBattery,endBattery,batteryGain]);;;;;;
[station,startstr,endstr,chargeDuration,startBattery,endBattery,batteryGain];;;;;;
init ;1;319;;;;
set autonomousBiketarget value: autonomousBike(target) ;0;319;;;;
autonomousBike(target);0;319;;;;
set autonomousBiketarget.chargeLogger value: self ;1;319;;;;
autonomousBiketarget.chargeLogger;;;;;;
set loggingAgent value: autonomousBiketarget ;0;319;;;;
species autonomousBikeLogger_roadsTraveled parent: Logger mirrors: autonomousBike ;235;2881;;;;
main_model host ;0;319;;;;
-29;;;;;;
list<autonomousBikeLogger_roadsTraveled> peers ;0;319;;;;
-199;;;;;;
string filename <- (((('AutonomousBike_roadstraveled' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second) ;1;319;;;;
(((('AutonomousBike_roadstraveled' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);1;319;;;;
((('AutonomousBike_roadstraveled' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';1;319;;;;
(('AutonomousBike_roadstraveled' + string(nowDate.hour)) + '_') + string(nowDate.minute);1;319;;;;
('AutonomousBike_roadstraveled' + string(nowDate.hour)) + '_';0;319;;;;
'AutonomousBike_roadstraveled' + string(nowDate.hour);0;319;;;;
string(nowDate.hour);0;319;;;;
nowDate.hour;0;319;;;;
string(nowDate.minute);1;319;;;;
nowDate.minute;1;319;;;;
string(nowDate.second);0;319;;;;
nowDate.second;0;319;;;;
list<string> columns <- ['Distance Traveled'] ;0;319;;;;
['Distance Traveled'];0;319;;;;
autonomousBike autonomousBiketarget ;0;319;;;;
float totalDistance <- 0.0 ;0;319;;;;
autonomousBike target ;0;319;;;;
-28;;;;;;
bool logPredicate ;0;328;;;;
return roadsTraveledLog ;0;328;;;;
action logRoads (float distanceTraveled);5;328;;;;
arg distanceTraveled type: float ;0;328;;;;
set totalDistance value: distanceTraveled ;0;328;;;;
do log (data:[distanceTraveled]);3;328;;;;
self.log(data:[distanceTraveled]);;;;;;
[distanceTraveled];;;;;;
init ;1;319;;;;
set autonomousBiketarget value: autonomousBike(target) ;0;319;;;;
autonomousBike(target);0;319;;;;
set autonomousBiketarget.travelLogger value: self ;0;319;;;;
autonomousBiketarget.travelLogger;;;;;;
set loggingAgent value: autonomousBiketarget ;1;319;;;;
species autonomousBikeLogger_event parent: Logger mirrors: autonomousBike ;253;2881;;;;
main_model host ;0;319;;;;
-29;;;;;;
list<autonomousBikeLogger_event> peers ;0;319;;;;
-199;;;;;;
string filename <- (((('autonomousBike_trip_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second) ;2;319;;;;
(((('autonomousBike_trip_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_') + string(nowDate.second);2;319;;;;
((('autonomousBike_trip_event' + string(nowDate.hour)) + '_') + string(nowDate.minute)) + '_';2;319;;;;
(('autonomousBike_trip_event' + string(nowDate.hour)) + '_') + string(nowDate.minute);2;319;;;;
('autonomousBike_trip_event' + string(nowDate.hour)) + '_';2;319;;;;
'autonomousBike_trip_event' + string(nowDate.hour);1;319;;;;
string(nowDate.hour);1;319;;;;
nowDate.hour;1;319;;;;
string(nowDate.minute);0;319;;;;
nowDate.minute;0;319;;;;
string(nowDate.second);0;319;;;;
nowDate.second;0;319;;;;
list<string> columns <- ['Event','Activity','Message','Start Time','End Time','Duration (min)','Distance Traveled','Start Battery %','End Battery %','Battery Gain %'] ;0;319;;;;
['Event','Activity','Message','Start Time','End Time','Duration (min)','Distance Traveled','Start Battery %','End Battery %','Battery Gain %'];0;319;;;;
autonomousBike autonomousBiketarget ;0;319;;;;
chargingStation stationCharging ;0;319;;;;
float chargingStartTime ;0;319;;;;
float batteryLifeBeginningCharge ;0;319;;;;
int cycleStartActivity ;0;319;;;;
date timeStartActivity ;0;319;;;;
point locationStartActivity ;1;319;;;;
float batteryStartActivity ;0;319;;;;
string currentState ;0;319;;;;
int activity ;0;319;;;;
autonomousBike target ;0;319;;;;
-28;;;;;;
bool logPredicate ;1;656;;;;
return autonomousBikeEventLog ;0;656;;;;
action logEnterState (string logmessage);33;328;;;;
arg logmessage type: string ;0;328;;;;
set cycleStartActivity value: cycle ;0;328;;;;
set timeStartActivity value: current_date ;1;328;;;;
set batteryStartActivity value: autonomousBiketarget.batteryLife ;2;328;;;;
autonomousBiketarget.batteryLife;2;328;;;;
set locationStartActivity value: autonomousBiketarget.location ;0;328;;;;
autonomousBiketarget.location;0;328;;;;
set currentState value: autonomousBiketarget.state ;1;328;;;;
autonomousBiketarget.state;1;328;;;;
set activity value: autonomousBiketarget.activity ;3;328;;;;
autonomousBiketarget.activity;1;328;;;;
do log (data:((['START: ' + autonomousBiketarget.state]) + ([activity])) + ([logmessage]));15;328;;;;
self.log(data:((['START: ' + autonomousBiketarget.state]) + ([activity])) + ([logmessage]));;;;;;
((['START: ' + autonomousBiketarget.state]) + ([activity])) + ([logmessage]);;;;;;
(['START: ' + autonomousBiketarget.state]) + ([activity]);;;;;;
['START: ' + autonomousBiketarget.state];;;;;;
'START: ' + autonomousBiketarget.state;;;;;;
autonomousBiketarget.state;;;;;;
[activity];;;;;;
[logmessage];;;;;;
action logExitState (string logmessage);307;328;;;;
arg logmessage type: string ;0;328;;;;
let d type: float value: autonomousBiketarget.travelLogger.totalDistance ;1;328;;;;
autonomousBiketarget.travelLogger.totalDistance;0;328;;;;
autonomousBiketarget.travelLogger;0;328;;;;
let timeStartstr type: string ;1;328;;;;
let currentstr type: string ;0;328;;;;
if timeStartActivity = nil ;3;328;;;;
timeStartActivity = nil;0;328;;;;
else ;3;328;;;;
set timeStartstr value: string(timeStartActivity,'HH:mm:ss') ;3;328;;;;
string(timeStartActivity,'HH:mm:ss');3;328;;;;
set timeStartstr value: nil ;;;;;;
if current_date = nil ;1;328;;;;
current_date = nil;0;328;;;;
else ;1;328;;;;
set currentstr value: string(current_date,'HH:mm:ss') ;1;328;;;;
string(current_date,'HH:mm:ss');0;328;;;;
set currentstr value: nil ;;;;;;
do log (data:['END: ' + currentState,activity,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,d,(batteryStartActivity / maxBatteryLifeAutonomousBike) * 100,(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100,((autonomousBiketarget.batteryLife - batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100]);17;328;;;;
self.log(data:['END: ' + currentState,activity,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,d,(batteryStartActivity / maxBatteryLifeAutonomousBike) * 100,(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100,((autonomousBiketarget.batteryLife - batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100]);;;;;;
['END: ' + currentState,activity,logmessage,timeStartstr,currentstr,((cycle * step) - (cycleStartActivity * step)) / 60,d,(batteryStartActivity / maxBatteryLifeAutonomousBike) * 100,(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100,((autonomousBiketarget.batteryLife - batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100];;;;;;
'END: ' + currentState;;;;;;
((cycle * step) - (cycleStartActivity * step)) / 60;;;;;;
(cycle * step) - (cycleStartActivity * step);;;;;;
cycle * step;;;;;;
cycleStartActivity * step;;;;;;
(batteryStartActivity / maxBatteryLifeAutonomousBike) * 100;;;;;;
batteryStartActivity / maxBatteryLifeAutonomousBike;;;;;;
(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100;;;;;;
autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike;;;;;;
autonomousBiketarget.batteryLife;;;;;;
((autonomousBiketarget.batteryLife - batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100;;;;;;
(autonomousBiketarget.batteryLife - batteryStartActivity) / maxBatteryLifeAutonomousBike;;;;;;
autonomousBiketarget.batteryLife - batteryStartActivity;;;;;;
autonomousBiketarget.batteryLife;;;;;;
if currentState = 'getting_charge' ;277;328;;;;
currentState = 'getting_charge';0;328;;;;
ask autonomousBiketarget.chargeLogger ;554;656;;;;
autonomousBiketarget.chargeLogger;0;328;;;;
do logCharge (station:closest_to(chargingStation,autonomousBiketarget), startTime:myself.timeStartActivity, endTime:current_date, chargeDuration:((cycle * step) - (myself.cycleStartActivity * step)) / 60, startBattery:(myself.batteryStartActivity / maxBatteryLifeAutonomousBike) * 100, endBattery:(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100, batteryGain:((autonomousBiketarget.batteryLife - myself.batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100);277;328;;;;
self.logCharge(station:closest_to(chargingStation,autonomousBiketarget), startTime:myself.timeStartActivity, endTime:current_date, chargeDuration:((cycle * step) - (myself.cycleStartActivity * step)) / 60, startBattery:(myself.batteryStartActivity / maxBatteryLifeAutonomousBike) * 100, endBattery:(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100, batteryGain:((autonomousBiketarget.batteryLife - myself.batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100);;;;;;
closest_to(chargingStation,autonomousBiketarget);;;;;;
myself.timeStartActivity;;;;;;
((cycle * step) - (myself.cycleStartActivity * step)) / 60;;;;;;
(cycle * step) - (myself.cycleStartActivity * step);;;;;;
cycle * step;;;;;;
myself.cycleStartActivity * step;;;;;;
myself.cycleStartActivity;;;;;;
(myself.batteryStartActivity / maxBatteryLifeAutonomousBike) * 100;;;;;;
myself.batteryStartActivity / maxBatteryLifeAutonomousBike;;;;;;
myself.batteryStartActivity;;;;;;
(autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike) * 100;;;;;;
autonomousBiketarget.batteryLife / maxBatteryLifeAutonomousBike;;;;;;
autonomousBiketarget.batteryLife;;;;;;
((autonomousBiketarget.batteryLife - myself.batteryStartActivity) / maxBatteryLifeAutonomousBike) * 100;;;;;;
(autonomousBiketarget.batteryLife - myself.batteryStartActivity) / maxBatteryLifeAutonomousBike;;;;;;
autonomousBiketarget.batteryLife - myself.batteryStartActivity;;;;;;
autonomousBiketarget.batteryLife;;;;;;
myself.batteryStartActivity;;;;;;
init ;1;319;;;;
set autonomousBiketarget value: autonomousBike(target) ;1;319;;;;
autonomousBike(target);1;319;;;;
set autonomousBiketarget.eventLogger value: self ;0;319;;;;
autonomousBiketarget.eventLogger;;;;;;
set loggingAgent value: autonomousBiketarget ;0;319;;;;
species road ;2556;2881;;;;
main_model host ;0;2281;;;;
-29;;;;;;
list<road> peers ;0;2281;;;;
-199;;;;;;
aspect base ;;;;;;
draw shape color: rgb(125,125,125) ;;;;;;
rgb(125,125,125);;;;;;
species CellcenterPoint ;20;2881;;;;
main_model host ;0;22;;;;
-29;;;;;;
list<CellcenterPoint> peers ;0;22;;;;
-199;;;;;;
aspect base ;;;;;;
set color value: #orangered ;;;;;;
draw triangle(float(100)) color: color ;;;;;;
triangle(float(100));;;;;;
float(100);;;;;;
species chargingStation ;477;2881;;;;
main_model host ;0;75;;;;
-29;;;;;;
list<chargingStation> peers ;0;75;;;;
-199;;;;;;
list<autonomousBike> autonomousBikesToCharge ;0;75;;;;
rgb color <- #deeppink ;0;75;;;;
float lat ;0;75;;;;
float lon ;0;75;;;;
int capacity ;0;75;;;;
reflex chargeBikes ;361;216075;;;;
ask first(capacity,autonomousBikesToCharge) ;327;217076;;;;
first(capacity,autonomousBikesToCharge);251;216075;;;;
set batteryLife value: batteryLife + (step * V2IChargingRate) ;10;1001;;;;
batteryLife + (step * V2IChargingRate);6;1001;;;;
step * V2IChargingRate;3;1001;;;;
aspect base ;;;;;;
draw hexagon(float(25),float(25)) color: color border: #black ;;;;;;
hexagon(float(25),float(25));;;;;;
float(25);;;;;;
float(25);;;;;;
species restaurant ;0;2881;;;;
main_model host ;;;;;;
-29;;;;;;
list<restaurant> peers ;;;;;;
-199;;;;;;
rgb color <- #sandybrown ;;;;;;
float lat ;;;;;;
float lon ;;;;;;
point rest ;;;;;;
aspect base ;;;;;;
draw circle(float(10)) color: color ;;;;;;
circle(float(10));;;;;;
float(10);;;;;;
species foodhotspot ;4;2881;;;;
main_model host ;0;5;;;;
-29;;;;;;
list<foodhotspot> peers ;0;5;;;;
-199;;;;;;
float lat ;0;5;;;;
float lon ;0;5;;;;
float dens ;0;5;;;;
aspect base ;;;;;;
draw hexagon(float(60)) color: #red ;;;;;;
hexagon(float(60));;;;;;
float(60);;;;;;
species userhotspot ;9;2881;;;;
main_model host ;0;10;;;;
-29;;;;;;
list<userhotspot> peers ;0;10;;;;
-199;;;;;;
float lat ;0;10;;;;
float lon ;0;10;;;;
float dens ;0;10;;;;
aspect base ;;;;;;
draw hexagon(float(60)) color: #blue ;;;;;;
hexagon(float(60));;;;;;
float(60);;;;;;
species package control: fsm skills: [moving] ;1000547;2881;;;;
[moving];;;;;;
main_model host ;6;30079;;;;
-29;;;;;;
list<package> peers ;14;30079;;;;
-199;;;;;;
float speed <- 1.0 ;39;30079;;;;
path current_path <- nil ;10;30079;;;;
point location ;48;30079;;;;
float heading <- rnd(360.0) ;16;30079;;;;
rnd(360.0);7;44614;;;;
geometry current_edge <- nil ;7;30079;;;;
point destination ;6;30079;;;;
float real_speed <- 0.0 ;5;30079;;;;
list states const: true ;24;30079;;;;
string state <- 'wandering' ;14;30079;;;;
rgb color ;4;30079;;;;
map<string, rgb> color_map <-  ['generated'::#transparent,'firstmile'::#lightsteelblue,'requestingAutonomousBike'::#red,'awaiting_autonomousBike_package'::#yellow,'delivering_autonomousBike'::#yellow,'lastmile'::#lightsteelblue,'retry'::#red,'delivered'::#transparent]  ;61;30079;;;;
 ['generated'::#transparent,'firstmile'::#lightsteelblue,'requestingAutonomousBike'::#red,'awaiting_autonomousBike_package'::#yellow,'delivering_autonomousBike'::#yellow,'lastmile'::#lightsteelblue,'retry'::#red,'delivered'::#transparent] ;52;30079;;;;
packageLogger logger ;9;30079;;;;
packageLogger_trip tripLogger ;5;30079;;;;
date start_hour ;6;30079;;;;
float start_lat ;9;30079;;;;
float start_lon ;3;30079;;;;
float target_lat ;7;30079;;;;
float target_lon ;3;30079;;;;
int start_d ;8;30079;;;;
point start_point ;1;30079;;;;
point target_point ;2;30079;;;;
int start_day ;4;30079;;;;
int start_h ;2;30079;;;;
int start_min ;6;30079;;;;
autonomousBike autonomousBikeToDeliver ;4;30079;;;;
point final_destination ;3;30079;;;;
point target ;3;30079;;;;
int queueTime ;4;30079;;;;
int bidClear <- 0 ;15;30079;;;;
float tripdistance <- 0.0 ;10;30079;;;;
float dynamic_maxDistancePackage <- maxDistancePackage_AutonomousBike ;16;30079;;;;
cell my_cell ;3;30079;;;;
path move (2 speed, 2 heading, 13 bounds);;;;;;
path goto (13 target, 2 speed, 0 on, 3 recompute_path, 3 return_path, 10 move_weights);12475;262647;;;;
bool wander (2 speed, 2 amplitude, 13 bounds, 15 on, 10 proba_edges);;;;;;
path follow (2 speed, 17 path, 10 move_weights, 3 return_path);;;;;;
action deliver (autonomousBike ab);18;5067;;;;
arg ab type: autonomousBike ;1;5067;;;;
set autonomousBikeToDeliver value: ab ;5;5067;;;;
bool timeToTravel ;519561;248100949;;;;
return (((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min)) and !overlaps(self,target_point) ;348064;248100949;;;;
(((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min)) and !overlaps(self,target_point);301669;248100949;;;;
((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min);265630;248100949;;;;
(current_date.day = start_day) and (current_date.hour = start_h);227845;248100949;;;;
current_date.day = start_day;168109;248100949;;;;
current_date.day;51982;248100949;;;;
current_date.hour = start_h;16658;31932367;;;;
current_date.hour;5841;31932367;;;;
current_date.minute >= start_min;689;1226806;;;;
current_date.minute;223;1226806;;;;
!overlaps(self,target_point);262;313858;;;;
overlaps(self,target_point);208;313858;;;;
reflex updateQueueTime ;273277;86657599;;;;
if self.timeToTravel() ;249833;86657599;;;;
self.timeToTravel();;;;;;
if current_date.hour = start_h ;386;159202;;;;
current_date.hour = start_h;98;159202;;;;
current_date.hour;40;159202;;;;
else ;;;;;;
if current_date.hour > start_h ;;;;;;
current_date.hour > start_h;;;;;;
current_date.hour;;;;;;
set queueTime value: ((((current_date.hour - start_h) - 1) * 60) + (60 - start_min)) + current_date.minute ;;;;;;
((((current_date.hour - start_h) - 1) * 60) + (60 - start_min)) + current_date.minute;;;;;;
(((current_date.hour - start_h) - 1) * 60) + (60 - start_min);;;;;;
((current_date.hour - start_h) - 1) * 60;;;;;;
(current_date.hour - start_h) - 1;;;;;;
current_date.hour - start_h;;;;;;
current_date.hour;;;;;;
60 - start_min;;;;;;
current_date.minute;;;;;;
set queueTime value: current_date.minute - start_min ;218;159202;;;;
current_date.minute - start_min;118;159202;;;;
current_date.minute;39;159202;;;;
reflex updateMaxDistance ;173445;86657599;;;;
set dynamic_maxDistancePackage value: maxDistancePackage_AutonomousBike - (queueTime * (DrivingSpeedAutonomousBike * #m)) ;149978;86657599;;;;
maxDistancePackage_AutonomousBike - (queueTime * (DrivingSpeedAutonomousBike * #m));108923;86657599;;;;
queueTime * (DrivingSpeedAutonomousBike * #m);79003;86657599;;;;
DrivingSpeedAutonomousBike * #m;26430;86657599;;;;
state wandering initial: true ;421256;80721675;;;;
enter ;305;30079;;;;
if packageEventLog or packageTripLog ;279;30079;;;;
packageEventLog or packageTripLog;17;30079;;;;
ask logger ;469;60158;;;;
do logEnterState ;203;30079;;;;
set target value: nil ;12;30079;;;;
transition to: bidding when: (self.timeToTravel()) and biddingEnabled ;;;;;;
(self.timeToTravel()) and biddingEnabled;191532;80721675;;;;
self.timeToTravel();;;;;;
set final_destination value: target_point ;;;;;;
transition to: requestingAutonomousBike when: (self.timeToTravel()) and !biddingEnabled ;2;5067;;;;
(self.timeToTravel()) and !biddingEnabled;186813;80721675;;;;
self.timeToTravel();;;;;;
!biddingEnabled;2;5067;;;;
set final_destination value: target_point ;1;5067;;;;
exit ;1;5067;;;;
if packageEventLog ;0;5067;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state requestingAutonomousBike ;15046;5067;;;;
enter ;108;5067;;;;
if packageEventLog or packageTripLog ;105;5067;;;;
packageEventLog or packageTripLog;1;5067;;;;
ask logger ;196;10134;;;;
do logEnterState ;90;5067;;;;
transition to: firstmile when: host.requestAutonomousBike(person:nil, pack:self) ;130;5067;;;;
host.requestAutonomousBike(person:nil, pack:self);;;;;;
set target value: closest_to(road,self).location ;128;5067;;;;
closest_to(road,self).location;122;5067;;;;
closest_to(road,self);113;5067;;;;
transition to: wandering when: !(host.requestAutonomousBike(person:nil, pack:self)) ;;;;;;
!(host.requestAutonomousBike(person:nil, pack:self));;;;;;
host.requestAutonomousBike(person:nil, pack:self);;;;;;
write 'ERROR: Package not delivered' ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logEvent (event:'Package not delivered');;;;;;
self.logEvent(event:'Package not delivered');;;;;;
set location value: final_destination ;;;;;;
exit ;6;5067;;;;
if packageEventLog ;2;5067;;;;
ask logger ;;;;;;
do logExitState (logmessage:'Requested Bike ' + myself.autonomousBikeToDeliver);;;;;;
self.logExitState(logmessage:'Requested Bike ' + myself.autonomousBikeToDeliver);;;;;;
'Requested Bike ' + myself.autonomousBikeToDeliver;;;;;;
myself.autonomousBikeToDeliver;;;;;;
state bidding ;;;;;;
enter ;;;;;;
if packageEventLog or packageTripLog ;;;;;;
packageEventLog or packageTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
set bidClear value: 0 ;;;;;;
set target value: closest_to(road,self).location ;;;;;;
closest_to(road,self).location;;;;;;
closest_to(road,self);;;;;;
transition to: awaiting_bike_assignation when: host.bidForBike(person:nil, pack:self) ;;;;;;
host.bidForBike(person:nil, pack:self);;;;;;
transition to: wandering when: !(host.bidForBike(person:nil, pack:self)) ;;;;;;
!(host.bidForBike(person:nil, pack:self));;;;;;
host.bidForBike(person:nil, pack:self);;;;;;
write 'ERROR: Package not delivered' ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logEvent (event:'Package not delivered');;;;;;
self.logEvent(event:'Package not delivered');;;;;;
set location value: final_destination ;;;;;;
exit ;;;;;;
if packageEventLog ;;;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state awaiting_bike_assignation ;;;;;;
enter ;;;;;;
if packageEventLog or packageTripLog ;;;;;;
packageEventLog or packageTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
transition to: requested_with_bid when: host.bikeAssigned(person:nil, pack:self) ;;;;;;
host.bikeAssigned(person:nil, pack:self);;;;;;
set target value: closest_to(road,self).location ;;;;;;
closest_to(road,self).location;;;;;;
closest_to(road,self);;;;;;
transition to: bidding when: bidClear = 1 ;;;;;;
bidClear = 1;;;;;;
write string(self) + 'lost bid, will bid again' ;;;;;;
string(self) + 'lost bid, will bid again';;;;;;
string(self);;;;;;
exit ;;;;;;
if packageEventLog ;;;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state requested_with_bid ;;;;;;
enter ;;;;;;
if packageEventLog or packageTripLog ;;;;;;
packageEventLog or packageTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
transition to: firstmile ;;;;;;
exit ;;;;;;
if packageEventLog ;;;;;;
ask logger ;;;;;;
do logExitState (logmessage:'Requested Bike ' + myself.autonomousBikeToDeliver);;;;;;
self.logExitState(logmessage:'Requested Bike ' + myself.autonomousBikeToDeliver);;;;;;
'Requested Bike ' + myself.autonomousBikeToDeliver;;;;;;
myself.autonomousBikeToDeliver;;;;;;
state firstmile ;1193;7037;;;;
enter ;42;5067;;;;
if packageEventLog or packageTripLog ;40;5067;;;;
packageEventLog or packageTripLog;1;5067;;;;
ask logger ;70;10134;;;;
do logEnterState ;29;5067;;;;
transition to: awaiting_autonomousBike_package when: location = target ;3;5067;;;;
location = target;4;7037;;;;
exit ;5;5067;;;;
if packageEventLog ;1;5067;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
do goto (target:target, on:roadNetwork);1122;7037;;;;
state awaiting_autonomousBike_package ;197;58598;;;;
enter ;90;5067;;;;
if packageEventLog or packageTripLog ;86;5067;;;;
packageEventLog or packageTripLog;4;5067;;;;
ask logger ;151;10134;;;;
do logEnterState (logmessage:'awaiting ' + string(myself.autonomousBikeToDeliver));67;5067;;;;
self.logEnterState(logmessage:'awaiting ' + string(myself.autonomousBikeToDeliver));;;;;;
'awaiting ' + string(myself.autonomousBikeToDeliver);;;;;;
string(myself.autonomousBikeToDeliver);;;;;;
myself.autonomousBikeToDeliver;;;;;;
transition to: delivering_autonomousBike when: autonomousBikeToDeliver.state = 'in_use_packages' ;3;5067;;;;
autonomousBikeToDeliver.state = 'in_use_packages';60;58598;;;;
autonomousBikeToDeliver.state;47;58598;;;;
set target value: nil ;1;5067;;;;
exit ;4;5067;;;;
if packageEventLog ;2;5067;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state delivering_autonomousBike ;816;118048;;;;
enter ;136;5067;;;;
if packageEventLog or packageTripLog ;132;5067;;;;
packageEventLog or packageTripLog;3;5067;;;;
ask logger ;250;10134;;;;
do logEnterState (logmessage:'delivering ' + string(myself.autonomousBikeToDeliver));118;5067;;;;
self.logEnterState(logmessage:'delivering ' + string(myself.autonomousBikeToDeliver));;;;;;
'delivering ' + string(myself.autonomousBikeToDeliver);;;;;;
string(myself.autonomousBikeToDeliver);;;;;;
myself.autonomousBikeToDeliver;;;;;;
transition to: lastmile when: autonomousBikeToDeliver.state != 'in_use_packages' ;8;5067;;;;
autonomousBikeToDeliver.state != 'in_use_packages';120;118048;;;;
autonomousBikeToDeliver.state;72;118048;;;;
set target value: final_destination ;3;5067;;;;
exit ;14;5067;;;;
if packageEventLog ;0;5067;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
set autonomousBikeToDeliver value: nil ;9;5067;;;;
set location value: autonomousBikeToDeliver.location ;393;118048;;;;
autonomousBikeToDeliver.location;124;118048;;;;
state lastmile ;1601;8422;;;;
enter ;119;5067;;;;
if packageEventLog or packageTripLog ;112;5067;;;;
packageEventLog or packageTripLog;6;5067;;;;
ask logger ;192;10134;;;;
do logEnterState ;74;5067;;;;
transition to: delivered when: location = target ;0;5067;;;;
location = target;8;8422;;;;
exit ;9;5067;;;;
if packageEventLog ;3;5067;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
do goto (target:target, on:roadNetwork);1436;8422;;;;
state delivered ;6736;5738752;;;;
enter ;4697;5067;;;;
set tripdistance value: host.distanceInGraph(origin:self.start_point, destination:self.target_point) ;772;5067;;;;
host.distanceInGraph(origin:self.start_point, destination:self.target_point);;;;;;
self.start_point;;;;;;
self.target_point;;;;;;
if packageEventLog or packageTripLog ;3920;5067;;;;
packageEventLog or packageTripLog;7;5067;;;;
ask logger ;7792;10134;;;;
do logEnterState ;3883;5067;;;;
aspect base ;;;;;;
set color value: color_map[state] ;;;;;;
color_map[state];;;;;;
[state];;;;;;
draw square(float(15)) color: color border: #black ;;;;;;
square(float(15));;;;;;
float(15);;;;;;
aspect test ;;;;;;
draw square(float(15)) color: #green ;;;;;;
square(float(15));;;;;;
float(15);;;;;;
species people control: fsm skills: [moving] ;479765;2881;;;;
[moving];;;;;;
main_model host ;0;14216;;;;
-29;;;;;;
list<people> peers ;3;14216;;;;
-199;;;;;;
float speed <- 1.0 ;11;14216;;;;
path current_path <- nil ;3;14216;;;;
point location ;15;14216;;;;
float heading <- rnd(360.0) ;7;14216;;;;
rnd(360.0);7;44614;;;;
geometry current_edge <- nil ;2;14216;;;;
point destination ;1;14216;;;;
float real_speed <- 0.0 ;6;14216;;;;
list states const: true ;5;14216;;;;
string state <- 'wandering' ;10;14216;;;;
rgb color ;2;14216;;;;
map<string, rgb> color_map <-  ['wandering'::#transparent,'requestingAutonomousBike'::#springgreen,'awaiting_autonomousBike'::#springgreen,'riding_autonomousBike'::#gamagreen,'firstmile'::#blue,'lastmile'::#blue]  ;25;14216;;;;
 ['wandering'::#transparent,'requestingAutonomousBike'::#springgreen,'awaiting_autonomousBike'::#springgreen,'riding_autonomousBike'::#gamagreen,'firstmile'::#blue,'lastmile'::#blue] ;18;14216;;;;
peopleLogger logger ;3;14216;;;;
peopleLogger_trip tripLogger ;1;14216;;;;
package delivery ;2;14216;;;;
date start_hour ;1;14216;;;;
float start_lat ;1;14216;;;;
float start_lon ;3;14216;;;;
float target_lat ;4;14216;;;;
float target_lon ;1;14216;;;;
point start_point ;4;14216;;;;
point target_point ;1;14216;;;;
int start_day ;1;14216;;;;
int start_h ;1;14216;;;;
int start_min ;5;14216;;;;
autonomousBike autonomousBikeToRide ;3;14216;;;;
point final_destination ;3;14216;;;;
point target ;0;14216;;;;
int queueTime ;1;14216;;;;
int bidClear ;83;14216;;;;
float tripdistance <- 0.0 ;4;14216;;;;
float dynamic_maxDistancePeople <- maxDistancePeople_AutonomousBike ;12;14216;;;;
cell my_cell ;2;14216;;;;
int register <- 0 ;4;14216;;;;
path move (2 speed, 2 heading, 13 bounds);;;;;;
path goto (13 target, 2 speed, 0 on, 3 recompute_path, 3 return_path, 10 move_weights);12475;262647;;;;
bool wander (2 speed, 2 amplitude, 13 bounds, 15 on, 10 proba_edges);;;;;;
path follow (2 speed, 17 path, 10 move_weights, 3 return_path);;;;;;
action ride (autonomousBike ab);14;2364;;;;
arg ab type: autonomousBike ;0;2364;;;;
if ab != nil ;9;2364;;;;
ab != nil;1;2364;;;;
set autonomousBikeToRide value: ab ;4;2364;;;;
bool timeToTravel ;252697;122706016;;;;
return (((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min)) and !overlaps(self,target_point) ;171851;122706016;;;;
(((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min)) and !overlaps(self,target_point);147073;122706016;;;;
((current_date.day = start_day) and (current_date.hour = start_h)) and (current_date.minute >= start_min);129805;122706016;;;;
(current_date.day = start_day) and (current_date.hour = start_h);111030;122706016;;;;
current_date.day = start_day;77864;122706016;;;;
current_date.day;26211;122706016;;;;
current_date.hour = start_h;10500;20408232;;;;
current_date.hour;3513;20408232;;;;
current_date.minute >= start_min;398;716978;;;;
current_date.minute;122;716978;;;;
!overlaps(self,target_point);184;291962;;;;
overlaps(self,target_point);143;291962;;;;
reflex updateQueueTime ;125113;40956296;;;;
if self.timeToTravel() ;113086;40956296;;;;
self.timeToTravel();;;;;;
if current_date.hour = start_h ;179;69395;;;;
current_date.hour = start_h;43;69395;;;;
current_date.hour;14;69395;;;;
else ;;;;;;
if current_date.hour > start_h ;;;;;;
current_date.hour > start_h;;;;;;
current_date.hour;;;;;;
set queueTime value: ((((current_date.hour - start_h) - 1) * 60) + (60 - start_min)) + current_date.minute ;;;;;;
((((current_date.hour - start_h) - 1) * 60) + (60 - start_min)) + current_date.minute;;;;;;
(((current_date.hour - start_h) - 1) * 60) + (60 - start_min);;;;;;
((current_date.hour - start_h) - 1) * 60;;;;;;
(current_date.hour - start_h) - 1;;;;;;
current_date.hour - start_h;;;;;;
current_date.hour;;;;;;
60 - start_min;;;;;;
current_date.minute;;;;;;
set queueTime value: current_date.minute - start_min ;95;69395;;;;
current_date.minute - start_min;40;69395;;;;
current_date.minute;8;69395;;;;
reflex updateMaxDistance ;79912;40956296;;;;
set dynamic_maxDistancePeople value: maxDistancePeople_AutonomousBike - (queueTime * (DrivingSpeedAutonomousBike * #m)) ;68925;40956296;;;;
maxDistancePeople_AutonomousBike - (queueTime * (DrivingSpeedAutonomousBike * #m));47494;40956296;;;;
queueTime * (DrivingSpeedAutonomousBike * #m);33302;40956296;;;;
DrivingSpeedAutonomousBike * #m;12252;40956296;;;;
state wandering initial: true ;219386;40874860;;;;
enter ;2135;16579;;;;
if peopleEventLog or peopleTripLog ;2108;16579;;;;
peopleEventLog or peopleTripLog;6;16579;;;;
ask logger ;4180;33158;;;;
do logEnterState ;2072;16579;;;;
set target value: nil ;22;16579;;;;
transition to: bidding when: (self.timeToTravel()) and biddingEnabled ;;;;;;
(self.timeToTravel()) and biddingEnabled;98103;40874860;;;;
self.timeToTravel();;;;;;
set final_destination value: target_point ;;;;;;
transition to: requestingAutonomousBike when: (self.timeToTravel()) and !biddingEnabled ;1;2364;;;;
(self.timeToTravel()) and !biddingEnabled;95467;40874860;;;;
self.timeToTravel();;;;;;
!biddingEnabled;0;2364;;;;
set final_destination value: target_point ;1;2364;;;;
exit ;3;2364;;;;
if peopleEventLog ;0;2364;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state requestingAutonomousBike ;6769;2364;;;;
enter ;40;2364;;;;
if peopleEventLog or peopleTripLog ;40;2364;;;;
peopleEventLog or peopleTripLog;3;2364;;;;
ask logger ;72;4728;;;;
do logEnterState ;33;2364;;;;
transition to: firstmile when: host.requestAutonomousBike(person:self, pack:nil) ;53;2364;;;;
host.requestAutonomousBike(person:self, pack:nil);;;;;;
set target value: closest_to(road,self).location ;52;2364;;;;
closest_to(road,self).location;48;2364;;;;
closest_to(road,self);46;2364;;;;
transition to: wandering ;;;;;;
write 'ERROR: Trip not served' ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logEvent (event:'Used another mode, wait too long');;;;;;
self.logEvent(event:'Used another mode, wait too long');;;;;;
set location value: final_destination ;;;;;;
exit ;4;2364;;;;
if peopleEventLog ;3;2364;;;;
ask logger ;;;;;;
do logExitState (logmessage:'Requested Bike ' + myself.autonomousBikeToRide);;;;;;
self.logExitState(logmessage:'Requested Bike ' + myself.autonomousBikeToRide);;;;;;
'Requested Bike ' + myself.autonomousBikeToRide;;;;;;
myself.autonomousBikeToRide;;;;;;
state bidding ;;;;;;
enter ;;;;;;
if peopleEventLog or peopleTripLog ;;;;;;
peopleEventLog or peopleTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
set bidClear value: 0 ;;;;;;
set target value: closest_to(road,self).location ;;;;;;
closest_to(road,self).location;;;;;;
closest_to(road,self);;;;;;
transition to: awaiting_bike_assignation when: host.bidForBike(person:self, pack:nil) ;;;;;;
host.bidForBike(person:self, pack:nil);;;;;;
transition to: wandering when: !(host.bidForBike(person:self, pack:nil)) ;;;;;;
!(host.bidForBike(person:self, pack:nil));;;;;;
host.bidForBike(person:self, pack:nil);;;;;;
write 'ERROR: Trip not served' ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logEvent (event:'Used another mode, wait too long');;;;;;
self.logEvent(event:'Used another mode, wait too long');;;;;;
set location value: final_destination ;;;;;;
exit ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state awaiting_bike_assignation ;;;;;;
enter ;;;;;;
if peopleEventLog or peopleTripLog ;;;;;;
peopleEventLog or peopleTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
transition to: requested_with_bid when: host.bikeAssigned(person:self, pack:nil) ;;;;;;
host.bikeAssigned(person:self, pack:nil);;;;;;
set target value: closest_to(road,self).location ;;;;;;
closest_to(road,self).location;;;;;;
closest_to(road,self);;;;;;
transition to: bidding when: bidClear = 1 ;;;;;;
bidClear = 1;;;;;;
write string(self) + 'lost bid, will bid again' ;;;;;;
string(self) + 'lost bid, will bid again';;;;;;
string(self);;;;;;
exit ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state requested_with_bid ;;;;;;
enter ;;;;;;
if peopleEventLog or peopleTripLog ;;;;;;
peopleEventLog or peopleTripLog;;;;;;
ask logger ;;;;;;
do logEnterState ;;;;;;
transition to: firstmile ;;;;;;
exit ;;;;;;
if peopleEventLog ;;;;;;
ask logger ;;;;;;
do logExitState (logmessage:'Requested Bike ' + myself.autonomousBikeToRide);;;;;;
self.logExitState(logmessage:'Requested Bike ' + myself.autonomousBikeToRide);;;;;;
'Requested Bike ' + myself.autonomousBikeToRide;;;;;;
myself.autonomousBikeToRide;;;;;;
state firstmile ;611;3598;;;;
enter ;38;2364;;;;
if peopleEventLog or peopleTripLog ;36;2364;;;;
peopleEventLog or peopleTripLog;1;2364;;;;
ask logger ;60;4728;;;;
do logEnterState ;27;2364;;;;
transition to: awaiting_autonomousBike when: location = target ;0;2364;;;;
location = target;1;3598;;;;
exit ;6;2364;;;;
if peopleEventLog ;3;2364;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
do goto (target:target, on:roadNetwork);560;3598;;;;
state awaiting_autonomousBike ;83;21239;;;;
enter ;41;2364;;;;
if peopleEventLog or peopleTripLog ;40;2364;;;;
peopleEventLog or peopleTripLog;0;2364;;;;
ask logger ;74;4728;;;;
do logEnterState (logmessage:'awaiting ' + string(myself.autonomousBikeToRide));33;2364;;;;
self.logEnterState(logmessage:'awaiting ' + string(myself.autonomousBikeToRide));;;;;;
'awaiting ' + string(myself.autonomousBikeToRide);;;;;;
string(myself.autonomousBikeToRide);;;;;;
myself.autonomousBikeToRide;;;;;;
transition to: riding_autonomousBike when: autonomousBikeToRide.state = 'in_use_people' ;3;2364;;;;
autonomousBikeToRide.state = 'in_use_people';18;21239;;;;
autonomousBikeToRide.state;9;21239;;;;
set target value: nil ;0;2364;;;;
exit ;4;2364;;;;
if peopleEventLog ;1;2364;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
state riding_autonomousBike ;352;50591;;;;
enter ;66;2364;;;;
if peopleEventLog or peopleTripLog ;63;2364;;;;
peopleEventLog or peopleTripLog;0;2364;;;;
ask logger ;117;4728;;;;
do logEnterState (logmessage:'riding ' + string(myself.autonomousBikeToRide));53;2364;;;;
self.logEnterState(logmessage:'riding ' + string(myself.autonomousBikeToRide));;;;;;
'riding ' + string(myself.autonomousBikeToRide);;;;;;
string(myself.autonomousBikeToRide);;;;;;
myself.autonomousBikeToRide;;;;;;
transition to: lastmile when: autonomousBikeToRide.state != 'in_use_people' ;1;2363;;;;
autonomousBikeToRide.state != 'in_use_people';68;50591;;;;
autonomousBikeToRide.state;43;50591;;;;
set target value: final_destination ;1;2363;;;;
exit ;3;2363;;;;
if peopleEventLog ;0;2363;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
set autonomousBikeToRide value: nil ;1;2363;;;;
set location value: autonomousBikeToRide.location ;176;50591;;;;
autonomousBikeToRide.location;48;50591;;;;
state lastmile ;1131;3644;;;;
enter ;50;2363;;;;
if peopleEventLog or peopleTripLog ;48;2363;;;;
peopleEventLog or peopleTripLog;4;2363;;;;
ask logger ;84;4726;;;;
do logEnterState ;34;2363;;;;
transition to: wandering when: location = target ;362;2363;;;;
location = target;6;3644;;;;
set tripdistance value: host.distanceInGraph(origin:self.start_point, destination:self.target_point) ;360;2363;;;;
host.distanceInGraph(origin:self.start_point, destination:self.target_point);;;;;;
self.start_point;;;;;;
self.target_point;;;;;;
exit ;12;2363;;;;
if peopleEventLog ;3;2363;;;;
ask logger ;;;;;;
do logExitState ;;;;;;
do goto (target:target, on:roadNetwork);686;3644;;;;
aspect base ;;;;;;
set color value: color_map[state] ;;;;;;
color_map[state];;;;;;
[state];;;;;;
draw circle(float(10)) color: color border: #black ;;;;;;
circle(float(10));;;;;;
float(10);;;;;;
aspect test ;;;;;;
draw circle(float(15)) color: #blue ;;;;;;
circle(float(15));;;;;;
float(15);;;;;;
species autonomousBike control: fsm skills: [moving] ;35419;2881;;;;
[moving];;;;;;
main_model host ;0;319;;;;
-29;;;;;;
list<autonomousBike> peers ;0;319;;;;
-199;;;;;;
float speed <- 1.0 ;3;319;;;;
path current_path <- nil ;0;319;;;;
point location ;1;319;;;;
float heading <- rnd(360.0) ;1;319;;;;
rnd(360.0);7;44614;;;;
geometry current_edge <- nil ;0;319;;;;
point destination ;0;319;;;;
float real_speed <- 0.0 ;0;319;;;;
list states const: true ;2;319;;;;
string state <- 'wandering' ;0;319;;;;
rgb color ;0;319;;;;
map<string, rgb> color_map <-  ['wandering'::#cyan,'low_battery'::#red,'getting_charge'::#red,'picking_up_people'::#springgreen,'picking_up_packages'::#mediumorchid,'in_use_people'::#gamagreen,'in_use_packages'::#purple,'rebalancing'::#gold]  ;2;319;;;;
 ['wandering'::#cyan,'low_battery'::#red,'getting_charge'::#red,'picking_up_people'::#springgreen,'picking_up_packages'::#mediumorchid,'in_use_people'::#gamagreen,'in_use_packages'::#purple,'rebalancing'::#gold] ;2;319;;;;
autonomousBikeLogger_roadsTraveled travelLogger ;0;319;;;;
autonomousBikeLogger_chargeEvents chargeLogger ;0;319;;;;
autonomousBikeLogger_event eventLogger ;0;319;;;;
people rider ;0;319;;;;
package delivery ;0;319;;;;
int activity ;0;319;;;;
bool biddingStart <- false ;0;319;;;;
float highestBid <- -100000.0 ;0;319;;;;
-100000.0;0;319;;;;
people highestBidderUser ;0;319;;;;
package highestBidderPackage ;0;319;;;;
list<people> personBidders ;0;319;;;;
list<package> packageBidders ;0;319;;;;
foodhotspot closest_f_hotspot ;0;319;;;;
userhotspot closest_u_hotspot ;0;319;;;;
int bid_start_h ;0;319;;;;
int bid_start_min ;0;319;;;;
int last_trip_day <- 7 ;0;319;;;;
int last_trip_h <- 12 ;0;319;;;;
cell my_cell ;0;319;;;;
cell rebalchosenCell ;0;319;;;;
point target ;0;319;;;;
float batteryLife min: 0.0 max: maxBatteryLifeAutonomousBike ;1;319;;;;
float distancePerCycle ;0;319;;;;
float distanceTraveledBike ;0;319;;;;
path travelledPath ;0;319;;;;
path move (2 speed, 2 heading, 13 bounds);;;;;;
path goto (13 target, 2 speed, 0 on, 3 recompute_path, 3 return_path, 10 move_weights);12475;262647;;;;
bool wander (2 speed, 2 amplitude, 13 bounds, 15 on, 10 proba_edges);;;;;;
path follow (2 speed, 17 path, 10 move_weights, 3 return_path);;;;;;
bool availableForRideAB ;17080;4241175;;;;
return ((((self.state = 'wandering') or (self.state = 'rebalancing')) and !(self.setLowBattery())) and (rider = nil)) and (delivery = nil) ;14239;4241175;;;;
((((self.state = 'wandering') or (self.state = 'rebalancing')) and !(self.setLowBattery())) and (rider = nil)) and (delivery = nil);13428;4241175;;;;
(((self.state = 'wandering') or (self.state = 'rebalancing')) and !(self.setLowBattery())) and (rider = nil);11867;4241175;;;;
((self.state = 'wandering') or (self.state = 'rebalancing')) and !(self.setLowBattery());10406;4241175;;;;
(self.state = 'wandering') or (self.state = 'rebalancing');4885;4241175;;;;
self.state = 'wandering';2756;4241175;;;;
self.state;1837;4241175;;;;
self.state = 'rebalancing';1168;2288418;;;;
self.state;712;2288418;;;;
!(self.setLowBattery());4499;1956147;;;;
self.setLowBattery();;;;;;
rider = nil;581;1953103;;;;
delivery = nil;628;1921075;;;;
action pickUp (people person, package pack);74;7431;;;;
arg person type: people ;1;7431;;;;
arg pack type: package ;1;7431;;;;
if person != nil ;46;7431;;;;
person != nil;3;7431;;;;
else ;27;5067;;;;
if pack != nil ;27;5067;;;;
pack != nil;2;5067;;;;
set delivery value: pack ;11;5067;;;;
set activity value: 0 ;8;5067;;;;
set rider value: person ;1;2364;;;;
set activity value: 1 ;4;2364;;;;
bool setLowBattery ;4803;2461328;;;;
if batteryLife < minSafeBatteryAutonomousBike ;3375;2461328;;;;
batteryLife < minSafeBatteryAutonomousBike;1382;2461328;;;;
else ;1056;2457956;;;;
return false ;423;2457956;;;;
return true ;0;3372;;;;
float energyCost (float distance);405;239946;;;;
arg distance type: float ;22;239946;;;;
return distance ;57;239946;;;;
action reduceBattery (float distance);1570;239946;;;;
arg distance type: float ;21;239946;;;;
set batteryLife value: batteryLife - (self.energyCost(distance:distance)) ;1219;239946;;;;
batteryLife - (self.energyCost(distance:distance));885;239946;;;;
self.energyCost(distance:distance);;;;;;
bool canMove ;3617;767463;;;;
return ((target != nil) and (target != location)) and (batteryLife > 0) ;1335;767463;;;;
((target != nil) and (target != location)) and (batteryLife > 0);1127;767463;;;;
(target != nil) and (target != location);815;767463;;;;
target != nil;460;767463;;;;
target != location;153;255422;;;;
batteryLife > 0;130;239946;;;;
bool rebalanceNeeded ;2519;502959;;;;
if (last_trip_day = current_date.day) and ((current_date.hour - last_trip_h) > 6) ;2162;502959;;;;
(last_trip_day = current_date.day) and ((current_date.hour - last_trip_h) > 6);1027;502959;;;;
last_trip_day = current_date.day;353;502959;;;;
current_date.day;139;502959;;;;
(current_date.hour - last_trip_h) > 6;490;502641;;;;
current_date.hour - last_trip_h;342;502641;;;;
current_date.hour;129;502641;;;;
else ;929;502916;;;;
if (last_trip_day < current_date.day) and ((current_date.hour + (24 - last_trip_h)) > 6) ;788;502916;;;;
(last_trip_day < current_date.day) and ((current_date.hour + (24 - last_trip_h)) > 6);363;502916;;;;
last_trip_day < current_date.day;286;502916;;;;
current_date.day;96;502916;;;;
(current_date.hour + (24 - last_trip_h)) > 6;0;318;;;;
current_date.hour + (24 - last_trip_h);0;318;;;;
current_date.hour;0;318;;;;
24 - last_trip_h;0;318;;;;
else ;219;502897;;;;
return false ;89;502897;;;;
return true ;0;19;;;;
return true ;0;43;;;;
path moveTowardTarget ;9761;239946;;;;
if state = 'in_use_people' ;2423;239946;;;;
state = 'in_use_people';147;239946;;;;
return self.goto(on:roadNetwork, target:target, return_path:true, speed:RidingSpeedAutonomousBike) ;2189;48227;;;;
self.goto(on:roadNetwork, target:target, return_path:true, speed:RidingSpeedAutonomousBike);;;;;;
return self.goto(on:roadNetwork, target:target, return_path:true, speed:DrivingSpeedAutonomousBike) ;7096;191719;;;;
self.goto(on:roadNetwork, target:target, return_path:true, speed:DrivingSpeedAutonomousBike);;;;;;
action receiveBid (people person, package pack, float bidValue);;;;;;
arg person type: people ;;;;;;
arg pack type: package ;;;;;;
arg bidValue type: float ;;;;;;
set biddingStart value: true ;;;;;;
if person != nil ;;;;;;
person != nil;;;;;;
else ;;;;;;
if pack != nil ;;;;;;
pack != nil;;;;;;
add pack to: packageBidders ;;;;;;
add person to: personBidders ;;;;;;
if highestBid = -100000.0 ;;;;;;
highestBid = -100000.0;;;;;;
-100000.0;;;;;;
set bid_start_h value: current_date.hour ;;;;;;
current_date.hour;;;;;;
set bid_start_min value: current_date.minute ;;;;;;
current_date.minute;;;;;;
if bidValue > highestBid ;;;;;;
bidValue > highestBid;;;;;;
set highestBidderUser value: nil ;;;;;;
set highestBidderPackage value: nil ;;;;;;
set highestBid value: bidValue ;;;;;;
if person != nil ;;;;;;
person != nil;;;;;;
else ;;;;;;
if package != nil ;;;;;;
package != nil;;;;;;
else ;;;;;;
write 'Error in receiveBid()' ;;;;;;
set highestBidderPackage value: pack ;;;;;;
set highestBidderUser value: person ;;;;;;
action endBidProcess ;;;;;;
loop i over: personBidders ;;;;;;
set i.bidClear value: 1 ;;;;;;
i.bidClear;;;;;;
loop j over: packageBidders ;;;;;;
set j.bidClear value: 1 ;;;;;;
j.bidClear;;;;;;
if (highestBidderUser != nil) and (highestBidderPackage = nil) ;;;;;;
(highestBidderUser != nil) and (highestBidderPackage = nil);;;;;;
highestBidderUser != nil;;;;;;
highestBidderPackage = nil;;;;;;
else ;;;;;;
if (highestBidderPackage != nil) and (highestBidderUser = nil) ;;;;;;
(highestBidderPackage != nil) and (highestBidderUser = nil);;;;;;
highestBidderPackage != nil;;;;;;
highestBidderUser = nil;;;;;;
else ;;;;;;
write 'Error: Confusion with highest bidder' ;;;;;;
do pickUp (person:nil, pack:highestBidderPackage);;;;;;
self.pickUp(person:nil, pack:highestBidderPackage);;;;;;
ask highestBidderPackage ;;;;;;
do deliver (ab:myself);;;;;;
self.deliver(ab:myself);;;;;;
do pickUp (person:highestBidderUser, pack:nil);;;;;;
self.pickUp(person:highestBidderUser, pack:nil);;;;;;
ask highestBidderUser ;;;;;;
do ride (ab:myself);;;;;;
self.ride(ab:myself);;;;;;
reflex move when: self.canMove() ;25171;767463;;;;
self.canMove();;;;;;
set travelledPath value: self.moveTowardTarget() ;10004;239946;;;;
self.moveTowardTarget();;;;;;
let distanceTraveled type: float value: host.distanceInGraph(origin:travelledPath.source, destination:travelledPath.target) ;8964;239946;;;;
host.distanceInGraph(origin:travelledPath.source, destination:travelledPath.target);;;;;;
travelledPath.source;;;;;;
travelledPath.target;;;;;;
do reduceBattery (distance:distanceTraveled);2011;239946;;;;
self.reduceBattery(distance:distanceTraveled);;;;;;
state wandering initial: true ;5832;510711;;;;
enter ;162;8113;;;;
if autonomousBikeEventLog ;4;8113;;;;
ask eventLogger ;;;;;;
do logEnterState ;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:0.0);;;;;;
self.logRoads(distanceTraveled:0.0);;;;;;
set target value: nil ;4;8113;;;;
set my_cell value: closest_to(cell,self.location) ;106;8113;;;;
closest_to(cell,self.location);90;8113;;;;
self.location;6;8113;;;;
set my_cell.numBikesCell value: my_cell.numBikesCell + 1 ;27;8113;;;;
my_cell.numBikesCell + 1;18;8113;;;;
my_cell.numBikesCell;13;8113;;;;
my_cell.numBikesCell;;;;;;
transition to: bidding when: (biddingStart = true) and biddingEnabled ;;;;;;
(biddingStart = true) and biddingEnabled;283;510711;;;;
biddingStart = true;208;510711;;;;
transition to: picking_up_people when: ((rider != nil) and (activity = 1)) and !biddingEnabled ;0;2363;;;;
((rider != nil) and (activity = 1)) and !biddingEnabled;358;510711;;;;
(rider != nil) and (activity = 1);273;510711;;;;
rider != nil;160;510711;;;;
activity = 1;0;2363;;;;
!biddingEnabled;1;2363;;;;
transition to: picking_up_packages when: ((delivery != nil) and (activity = 0)) and !biddingEnabled ;1;5062;;;;
((delivery != nil) and (activity = 0)) and !biddingEnabled;357;508348;;;;
(delivery != nil) and (activity = 0);277;508348;;;;
delivery != nil;194;508348;;;;
activity = 0;3;5062;;;;
!biddingEnabled;1;5062;;;;
transition to: low_battery when: self.setLowBattery() ;1;327;;;;
self.setLowBattery();;;;;;
transition to: rebalancing when: (self.rebalanceNeeded()) and rebalEnabled ;0;62;;;;
(self.rebalanceNeeded()) and rebalEnabled;2736;502959;;;;
self.rebalanceNeeded();;;;;;
exit ;53;7814;;;;
if autonomousBikeEventLog ;5;7814;;;;
ask eventLogger ;;;;;;
do logExitState ;;;;;;
set my_cell.numBikesCell value: my_cell.numBikesCell - 1 ;32;7814;;;;
my_cell.numBikesCell - 1;22;7814;;;;
my_cell.numBikesCell;16;7814;;;;
my_cell.numBikesCell;;;;;;
set my_cell value: nil ;5;7814;;;;
state rebalancing ;16;1937;;;;
enter ;3;43;;;;
if autonomousBikeEventLog ;0;43;;;;
ask eventLogger ;;;;;;
do logEnterState ;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:0.0);;;;;;
self.logRoads(distanceTraveled:0.0);;;;;;
if packagesEnabled and !peopleEnabled ;3;43;;;;
packagesEnabled and !peopleEnabled;0;43;;;;
!peopleEnabled;0;43;;;;
else ;3;43;;;;
if !packagesEnabled and peopleEnabled ;3;43;;;;
!packagesEnabled and peopleEnabled;0;43;;;;
!packagesEnabled;0;43;;;;
else ;3;43;;;;
if packagesEnabled and peopleEnabled ;3;43;;;;
packagesEnabled and peopleEnabled;0;43;;;;
let usedCells type: list<cell> value: cell where (each.used = true) ;0;43;;;;
cell where (each.used = true);0;43;;;;
each.used = true;0;1548;;;;
each.used;0;1548;;;;
let cellsinNeed type: list<cell> value: usedCells where (each.numBikesCell < 1) ;1;43;;;;
usedCells where (each.numBikesCell < 1);1;43;;;;
each.numBikesCell < 1;1;946;;;;
each.numBikesCell;0;946;;;;
set closest_f_hotspot value: closest_to(foodhotspot,self) ;1;43;;;;
closest_to(foodhotspot,self);0;43;;;;
set closest_u_hotspot value: closest_to(userhotspot,self) ;0;43;;;;
closest_to(userhotspot,self);0;43;;;;
if distance_to(closest_f_hotspot,self) < distance_to(closest_u_hotspot,self) ;1;43;;;;
distance_to(closest_f_hotspot,self) < distance_to(closest_u_hotspot,self);0;43;;;;
distance_to(closest_f_hotspot,self);0;43;;;;
distance_to(closest_u_hotspot,self);0;43;;;;
else ;1;42;;;;
if distance_to(closest_f_hotspot,self) > distance_to(closest_u_hotspot,self) ;1;42;;;;
distance_to(closest_f_hotspot,self) > distance_to(closest_u_hotspot,self);1;42;;;;
distance_to(closest_f_hotspot,self);0;42;;;;
distance_to(closest_u_hotspot,self);0;42;;;;
set target value: closest_u_hotspot.location ;0;42;;;;
closest_u_hotspot.location;0;42;;;;
set target value: closest_f_hotspot.location ;0;1;;;;
closest_f_hotspot.location;0;1;;;;
let usedCells type: list<cell> value: cell where (each.used = true) ;;;;;;
cell where (each.used = true);;;;;;
each.used = true;;;;;;
each.used;;;;;;
let cellsinNeed type: list<cell> value: usedCells where (each.numBikesCell < 5) ;;;;;;
usedCells where (each.numBikesCell < 5);;;;;;
each.numBikesCell < 5;;;;;;
each.numBikesCell;;;;;;
if float(length(cellsinNeed)) != 0 ;;;;;;
float(length(cellsinNeed)) != 0;;;;;;
float(length(cellsinNeed));;;;;;
length(cellsinNeed);;;;;;
else ;;;;;;
set target value: location ;;;;;;
set rebalchosenCell value: closest_to(cellsinNeed,self) ;;;;;;
closest_to(cellsinNeed,self);;;;;;
set rebalchosenCell.numBikesCell value: rebalchosenCell.numBikesCell + 1 ;;;;;;
rebalchosenCell.numBikesCell + 1;;;;;;
rebalchosenCell.numBikesCell;;;;;;
rebalchosenCell.numBikesCell;;;;;;
write (('Cells in need: ' + length(cellsinNeed)) + ' chosen cell: ') + rebalchosenCell ;;;;;;
(('Cells in need: ' + length(cellsinNeed)) + ' chosen cell: ') + rebalchosenCell;;;;;;
('Cells in need: ' + length(cellsinNeed)) + ' chosen cell: ';;;;;;
'Cells in need: ' + length(cellsinNeed);;;;;;
length(cellsinNeed);;;;;;
set target value: rebalchosenCell.centerRoadpoint ;;;;;;
rebalchosenCell.centerRoadpoint;;;;;;
set closest_f_hotspot value: closest_to(foodhotspot,self) ;;;;;;
closest_to(foodhotspot,self);;;;;;
set target value: closest_f_hotspot.location ;;;;;;
closest_f_hotspot.location;;;;;;
transition to: wandering when: location = target ;0;36;;;;
location = target;1;1937;;;;
transition to: bidding when: (biddingStart = true) and biddingEnabled ;;;;;;
(biddingStart = true) and biddingEnabled;1;1901;;;;
biddingStart = true;0;1901;;;;
transition to: picking_up_people when: ((rider != nil) and (activity = 1)) and !biddingEnabled ;0;1;;;;
((rider != nil) and (activity = 1)) and !biddingEnabled;0;1901;;;;
(rider != nil) and (activity = 1);0;1901;;;;
rider != nil;0;1901;;;;
activity = 1;0;1;;;;
!biddingEnabled;0;1;;;;
transition to: picking_up_packages when: ((delivery != nil) and (activity = 0)) and !biddingEnabled ;0;5;;;;
((delivery != nil) and (activity = 0)) and !biddingEnabled;1;1900;;;;
(delivery != nil) and (activity = 0);1;1900;;;;
delivery != nil;1;1900;;;;
activity = 0;0;5;;;;
!biddingEnabled;0;5;;;;
transition to: low_battery when: self.setLowBattery() ;0;1;;;;
self.setLowBattery();;;;;;
exit ;0;43;;;;
set last_trip_day value: current_date.day ;0;43;;;;
current_date.day;0;43;;;;
set last_trip_h value: current_date.hour ;0;43;;;;
current_date.hour;0;43;;;;
if rebalchosenCell != nil ;0;43;;;;
rebalchosenCell != nil;0;43;;;;
set rebalchosenCell.numBikesCell value: rebalchosenCell.numBikesCell - 1 ;;;;;;
rebalchosenCell.numBikesCell - 1;;;;;;
rebalchosenCell.numBikesCell;;;;;;
rebalchosenCell.numBikesCell;;;;;;
if autonomousBikeEventLog ;0;43;;;;
ask eventLogger ;;;;;;
do logExitState ;;;;;;
state bidding ;;;;;;
enter ;;;;;;
if autonomousBikeEventLog ;;;;;;
ask eventLogger ;;;;;;
do logEnterState ;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:0.0);;;;;;
self.logRoads(distanceTraveled:0.0);;;;;;
transition to: endBid when: ((highestBid != -100000.0) and ((current_date.hour = bid_start_h) and (current_date.minute > (bid_start_min + maxBiddingTime)))) or ((current_date.hour > bid_start_h) and (((60 - bid_start_min) + current_date.minute) > maxBiddingTime)) ;;;;;;
((highestBid != -100000.0) and ((current_date.hour = bid_start_h) and (current_date.minute > (bid_start_min + maxBiddingTime)))) or ((current_date.hour > bid_start_h) and (((60 - bid_start_min) + current_date.minute) > maxBiddingTime));;;;;;
(highestBid != -100000.0) and ((current_date.hour = bid_start_h) and (current_date.minute > (bid_start_min + maxBiddingTime)));;;;;;
highestBid != -100000.0;;;;;;
-100000.0;;;;;;
(current_date.hour = bid_start_h) and (current_date.minute > (bid_start_min + maxBiddingTime));;;;;;
current_date.hour = bid_start_h;;;;;;
current_date.hour;;;;;;
current_date.minute > (bid_start_min + maxBiddingTime);;;;;;
current_date.minute;;;;;;
bid_start_min + maxBiddingTime;;;;;;
(current_date.hour > bid_start_h) and (((60 - bid_start_min) + current_date.minute) > maxBiddingTime);;;;;;
current_date.hour > bid_start_h;;;;;;
current_date.hour;;;;;;
((60 - bid_start_min) + current_date.minute) > maxBiddingTime;;;;;;
(60 - bid_start_min) + current_date.minute;;;;;;
60 - bid_start_min;;;;;;
current_date.minute;;;;;;
exit ;;;;;;
if autonomousBikeEventLog ;;;;;;
ask eventLogger ;;;;;;
do logExitState ;;;;;;
state endBid ;;;;;;
enter ;;;;;;
if autonomousBikeEventLog ;;;;;;
ask eventLogger ;;;;;;
do logEnterState ;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:0.0);;;;;;
self.logRoads(distanceTraveled:0.0);;;;;;
do endBidProcess ;;;;;;
self.endBidProcess();;;;;;
set biddingStart value: false ;;;;;;
set highestBid value: -100000.0 ;;;;;;
-100000.0;;;;;;
set highestBidderUser value: nil ;;;;;;
set highestBidderPackage value: nil ;;;;;;
set personBidders value: [] ;;;;;;
[];;;;;;
set packageBidders value: [] ;;;;;;
[];;;;;;
set bid_start_h value: nil ;;;;;;
set bid_start_min value: nil ;;;;;;
transition to: picking_up_people when: (rider != nil) and (activity = 1) ;;;;;;
(rider != nil) and (activity = 1);;;;;;
rider != nil;;;;;;
activity = 1;;;;;;
transition to: picking_up_packages when: (delivery != nil) and (activity = 0) ;;;;;;
(delivery != nil) and (activity = 0);;;;;;
delivery != nil;;;;;;
activity = 0;;;;;;
exit ;;;;;;
if autonomousBikeEventLog ;;;;;;
ask eventLogger ;;;;;;
do logExitState ;;;;;;
state low_battery ;32;1806;;;;
enter ;30;328;;;;
set target value: closest_to(chargingStation,self).location ;8;328;;;;
closest_to(chargingStation,self).location;8;328;;;;
closest_to(chargingStation,self);8;328;;;;
let target_intersection type: point value: closest_to(roadNetwork.vertices,target) ;4;328;;;;
closest_to(roadNetwork.vertices,target);4;328;;;;
roadNetwork.vertices;0;328;;;;
set distanceTraveledBike value: host.distanceInGraph(origin:target_intersection, destination:location) ;17;328;;;;
host.distanceInGraph(origin:target_intersection, destination:location);;;;;;
if autonomousBikeEventLog ;0;328;;;;
ask eventLogger ;;;;;;
do logEnterState (logmessage:myself.state);;;;;;
self.logEnterState(logmessage:myself.state);;;;;;
myself.state;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:myself.distanceTraveledBike);;;;;;
self.logRoads(distanceTraveled:myself.distanceTraveledBike);;;;;;
myself.distanceTraveledBike;;;;;;
transition to: getting_charge when: location = target ;0;328;;;;
location = target;0;1806;;;;
exit ;0;328;;;;
if autonomousBikeEventLog ;0;328;;;;
ask eventLogger ;;;;;;
do logExitState ;;;;;;
state getting_charge ;372;1329;;;;
enter ;51;328;;;;
if stationChargeLogs ;44;328;;;;
ask eventLogger ;76;656;;;;
do logEnterState (logmessage:'Charging at ' + closest_to(chargingStation,myself));36;328;;;;
self.logEnterState(logmessage:'Charging at ' + closest_to(chargingStation,myself));;;;;;
'Charging at ' + closest_to(chargingStation,myself);;;;;;
closest_to(chargingStation,myself);;;;;;
ask travelLogger ;11;656;;;;
do logRoads (distanceTraveled:0.0);5;328;;;;
self.logRoads(distanceTraveled:0.0);;;;;;
set target value: nil ;1;328;;;;
ask closest_to(chargingStation,self) ;9;656;;;;
closest_to(chargingStation,self);1;328;;;;
set autonomousBikesToCharge value: autonomousBikesToCharge + myself ;4;328;;;;
autonomousBikesToCharge + myself;2;328;;;;
transition to: wandering when: batteryLife >= maxBatteryLifeAutonomousBike ;1;328;;;;
batteryLife >= maxBatteryLifeAutonomousBike;1;1329;;;;
exit ;317;328;;;;
if stationChargeLogs ;309;328;;;;
ask eventLogger ;617;656;;;;
do logExitState (logmessage:'Charged at ' + closest_to(chargingStation,myself));307;328;;;;
self.logExitState(logmessage:'Charged at ' + closest_to(chargingStation,myself));;;;;;
'Charged at ' + closest_to(chargingStation,myself);;;;;;
closest_to(chargingStation,myself);;;;;;
ask closest_to(chargingStation,self) ;12;656;;;;
closest_to(chargingStation,self);4;328;;;;
set autonomousBikesToCharge value: autonomousBikesToCharge - myself ;3;328;;;;
autonomousBikesToCharge - myself;0;328;;;;
state picking_up_people ;225;22473;;;;
enter ;169;2364;;;;
set target value: rider.target ;9;2364;;;;
rider.target;6;2364;;;;
let target_intersection type: point value: closest_to(roadNetwork.vertices,target) ;25;2364;;;;
closest_to(roadNetwork.vertices,target);23;2364;;;;
roadNetwork.vertices;1;2364;;;;
set distanceTraveledBike value: host.distanceInGraph(origin:target_intersection, destination:location) ;128;2364;;;;
host.distanceInGraph(origin:target_intersection, destination:location);;;;;;
if autonomousBikeEventLog ;1;2364;;;;
ask eventLogger ;;;;;;
do logEnterState (logmessage:'Picking up ' + myself.rider);;;;;;
self.logEnterState(logmessage:'Picking up ' + myself.rider);;;;;;
'Picking up ' + myself.rider;;;;;;
myself.rider;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:myself.distanceTraveledBike);;;;;;
self.logRoads(distanceTraveled:myself.distanceTraveledBike);;;;;;
myself.distanceTraveledBike;;;;;;
transition to: in_use_people when: (location = target) and (rider.location = target) ;0;2364;;;;
(location = target) and (rider.location = target);27;22473;;;;
location = target;11;22473;;;;
rider.location = target;4;2490;;;;
rider.location;4;2490;;;;
exit ;6;2364;;;;
if autonomousBikeEventLog ;2;2364;;;;
ask eventLogger ;;;;;;
do logExitState (logmessage:'Picked up ' + myself.rider);;;;;;
self.logExitState(logmessage:'Picked up ' + myself.rider);;;;;;
'Picked up ' + myself.rider;;;;;;
myself.rider;;;;;;
state picking_up_packages ;590;60568;;;;
enter ;396;5067;;;;
set target value: delivery.target ;12;5067;;;;
delivery.target;5;5067;;;;
let target_intersection type: point value: closest_to(roadNetwork.vertices,target) ;57;5067;;;;
closest_to(roadNetwork.vertices,target);52;5067;;;;
roadNetwork.vertices;1;5067;;;;
set distanceTraveledBike value: host.distanceInGraph(origin:target_intersection, destination:location) ;303;5067;;;;
host.distanceInGraph(origin:target_intersection, destination:location);;;;;;
if autonomousBikeEventLog ;5;5067;;;;
ask eventLogger ;;;;;;
do logEnterState (logmessage:'Picking up ' + myself.delivery);;;;;;
self.logEnterState(logmessage:'Picking up ' + myself.delivery);;;;;;
'Picking up ' + myself.delivery;;;;;;
myself.delivery;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:myself.distanceTraveledBike);;;;;;
self.logRoads(distanceTraveled:myself.distanceTraveledBike);;;;;;
myself.distanceTraveledBike;;;;;;
transition to: in_use_packages when: (location = target) and (delivery.location = target) ;1;5067;;;;
(location = target) and (delivery.location = target);72;60568;;;;
location = target;32;60568;;;;
delivery.location = target;10;5192;;;;
delivery.location;6;5192;;;;
exit ;10;5067;;;;
if autonomousBikeEventLog ;5;5067;;;;
ask eventLogger ;;;;;;
do logExitState (logmessage:'Picked up ' + myself.delivery);;;;;;
self.logExitState(logmessage:'Picked up ' + myself.delivery);;;;;;
'Picked up ' + myself.delivery;;;;;;
myself.delivery;;;;;;
state in_use_people ;816;50591;;;;
enter ;699;2364;;;;
set target value: closest_to(road,rider.final_destination).location ;48;2364;;;;
closest_to(road,rider.final_destination).location;47;2364;;;;
closest_to(road,rider.final_destination);45;2364;;;;
rider.final_destination;2;2364;;;;
let target_intersection type: point value: closest_to(roadNetwork.vertices,target) ;29;2364;;;;
closest_to(roadNetwork.vertices,target);26;2364;;;;
roadNetwork.vertices;2;2364;;;;
set distanceTraveledBike value: host.distanceInGraph(origin:target_intersection, destination:location) ;614;2364;;;;
host.distanceInGraph(origin:target_intersection, destination:location);;;;;;
if autonomousBikeEventLog ;2;2364;;;;
ask eventLogger ;;;;;;
do logEnterState (logmessage:'In Use ' + myself.rider);;;;;;
self.logEnterState(logmessage:'In Use ' + myself.rider);;;;;;
'In Use ' + myself.rider;;;;;;
myself.rider;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:myself.distanceTraveledBike);;;;;;
self.logRoads(distanceTraveled:myself.distanceTraveledBike);;;;;;
myself.distanceTraveledBike;;;;;;
transition to: wandering when: location = target ;14;2363;;;;
location = target;27;50591;;;;
set rider value: nil ;2;2363;;;;
set last_trip_day value: current_date.day ;3;2363;;;;
current_date.day;0;2363;;;;
set last_trip_h value: current_date.hour ;1;2363;;;;
current_date.hour;0;2363;;;;
exit ;1;2363;;;;
if autonomousBikeEventLog ;0;2363;;;;
ask eventLogger ;;;;;;
do logExitState (logmessage:'Used' + myself.rider);;;;;;
self.logExitState(logmessage:'Used' + myself.rider);;;;;;
'Used' + myself.rider;;;;;;
myself.rider;;;;;;
state in_use_packages ;1454;118048;;;;
enter ;1167;5067;;;;
set target value: closest_to(road,delivery.final_destination).location ;131;5067;;;;
closest_to(road,delivery.final_destination).location;131;5067;;;;
closest_to(road,delivery.final_destination);125;5067;;;;
delivery.final_destination;4;5067;;;;
let target_intersection type: point value: closest_to(roadNetwork.vertices,target) ;70;5067;;;;
closest_to(roadNetwork.vertices,target);66;5067;;;;
roadNetwork.vertices;4;5067;;;;
set distanceTraveledBike value: host.distanceInGraph(origin:target_intersection, destination:location) ;943;5067;;;;
host.distanceInGraph(origin:target_intersection, destination:location);;;;;;
if autonomousBikeEventLog ;4;5067;;;;
ask eventLogger ;;;;;;
do logEnterState (logmessage:'In Use ' + myself.delivery);;;;;;
self.logEnterState(logmessage:'In Use ' + myself.delivery);;;;;;
'In Use ' + myself.delivery;;;;;;
myself.delivery;;;;;;
ask travelLogger ;;;;;;
do logRoads (distanceTraveled:myself.distanceTraveledBike);;;;;;
self.logRoads(distanceTraveled:myself.distanceTraveledBike);;;;;;
myself.distanceTraveledBike;;;;;;
transition to: wandering when: location = target ;21;5067;;;;
location = target;62;118048;;;;
set delivery value: nil ;0;5067;;;;
set last_trip_day value: current_date.day ;11;5067;;;;
current_date.day;3;5067;;;;
set last_trip_h value: current_date.hour ;4;5067;;;;
current_date.hour;2;5067;;;;
exit ;7;5067;;;;
if autonomousBikeEventLog ;2;5067;;;;
ask eventLogger ;;;;;;
do logExitState (logmessage:'Used' + myself.delivery);;;;;;
self.logExitState(logmessage:'Used' + myself.delivery);;;;;;
'Used' + myself.delivery;;;;;;
myself.delivery;;;;;;
aspect realistic ;;;;;;
set color value: color_map[state] ;;;;;;
color_map[state];;;;;;
[state];;;;;;
if state != 'newborn' ;;;;;;
state != 'newborn';;;;;;
else ;;;;;;
draw circle(float(100)) color: #pink border: #pink rotate: heading + 90 ;;;;;;
heading + 90;;;;;;
circle(float(100));;;;;;
float(100);;;;;;
draw triangle(float(50)) color: color border: color rotate: heading + 90 ;;;;;;
heading + 90;;;;;;
triangle(float(50));;;;;;
float(50);;;;;;
grid cell width: 6 height: 6 neighbors: 6 ;679;2881;;;;
main_model host ;0;36;;;;
-29;;;;;;
list<cell> peers ;0;36;;;;
-199;;;;;;
list<float> bands ;0;36;;;;
int grid_x const: true ;0;36;;;;
list<cell> neighbors ;1;36;;;;
-199;;;;;;
int grid_y const: true ;0;36;;;;
rgb color <- rgb(min([255,colorValue]),max([0,255 - colorValue]),0) update: rgb(min([255,colorValue]),max([0,255 - colorValue]),0) ;404;103752;;;;
rgb(min([255,colorValue]),max([0,255 - colorValue]),0);0;36;;;;
min([255,colorValue]);0;36;;;;
[255,colorValue];0;36;;;;
max([0,255 - colorValue]);0;36;;;;
[0,255 - colorValue];0;36;;;;
255 - colorValue;0;36;;;;
rgb(min([255,colorValue]),max([0,255 - colorValue]),0);364;103716;;;;
min([255,colorValue]);192;103716;;;;
[255,colorValue];169;103716;;;;
max([0,255 - colorValue]);127;103716;;;;
[0,255 - colorValue];105;103716;;;;
255 - colorValue;40;103716;;;;
float grid_value ;0;36;;;;
bool used <- false ;0;36;;;;
int numBikesCell <- 0 ;0;36;;;;
point centerRoadpoint ;0;36;;;;
int colorValue <- int(255 * (numBikesCell * 0.1)) update: int(255 * (numBikesCell * 0.1)) ;172;103752;;;;
int(255 * (numBikesCell * 0.1));0;36;;;;
255 * (numBikesCell * 0.1);0;36;;;;
numBikesCell * 0.1;0;36;;;;
int(255 * (numBikesCell * 0.1));127;103716;;;;
255 * (numBikesCell * 0.1);103;103716;;;;
numBikesCell * 0.1;91;103716;;;;
init ;4276;1;;;;
do logSetUp ;17;1;;;;
create road from: roads_shapefile ;292;1;;;;
set roadNetwork value: as_edge_graph(road) ;4;1;;;;
as_edge_graph(road);3;1;;;;
create chargingStation from: chargingStations_csv with: [lat::float(get('Latitude')), lon::float(get('Longitude')), capacity::int(get('Total docks'))];8;76;;;;
set location value: to_GAMA_CRS(point(lon,lat),'EPSG:4326').location ;1;75;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326').location;1;75;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326');1;75;;;;
point(lon,lat);1;75;;;;
set chargingStationCapacity value: chargingStationCapacity ;2;75;;;;
create autonomousBike number: numAutonomousBikes ;13;218;;;;
set location value: point(one_of(roadNetwork.vertices)) ;2;217;;;;
point(one_of(roadNetwork.vertices));1;217;;;;
one_of(roadNetwork.vertices);1;217;;;;
roadNetwork.vertices;1;217;;;;
set batteryLife value: rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike) ;1;217;;;;
rnd(minSafeBatteryAutonomousBike,maxBatteryLifeAutonomousBike);0;217;;;;
let week type: int value: 0 ;0;1;;;;
loop times: numberOfWeeks ;3945;1;;;;
if packagesEnabled ;2645;1;;;;
create package from: pdemand_csv with: [start_hour::date(get('start_time')), start_lat::float(get('start_latitude')), start_lon::float(get('start_longitude')), target_lat::float(get('end_latitude')), target_lon::float(get('end_longitude')), start_d::int(get('day'))];4383;30080;;;;
set start_point value: to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326').location ;590;30079;;;;
to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326').location;572;30079;;;;
to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326');563;30079;;;;
point(start_lon,start_lat);27;30079;;;;
set target_point value: to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326').location ;500;30079;;;;
to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326').location;478;30079;;;;
to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326');473;30079;;;;
point(target_lon,target_lat);21;30079;;;;
set location value: start_point ;96;30079;;;;
set start_day value: start_d + 6 ;31;30079;;;;
start_d + 6;15;30079;;;;
set start_day value: (week * 7) + start_day ;40;30079;;;;
(week * 7) + start_day;34;30079;;;;
week * 7;19;30079;;;;
let start_h_str type: string value: string(start_hour,'kk') ;47;30079;;;;
string(start_hour,'kk');31;30079;;;;
set start_h value: int(start_h_str) ;40;30079;;;;
int(start_h_str);28;30079;;;;
if start_h = 24 ;18;30079;;;;
start_h = 24;14;30079;;;;
set start_h value: 0 ;0;15;;;;
let start_min_str type: string value: string(start_hour,'mm') ;123;30079;;;;
string(start_hour,'mm');116;30079;;;;
set start_min value: int(start_min_str) ;33;30079;;;;
int(start_min_str);22;30079;;;;
set my_cell value: closest_to(cell,self) ;128;30079;;;;
closest_to(cell,self);111;30079;;;;
set my_cell.used value: true ;15;30079;;;;
my_cell.used;;;;;;
set my_cell.color value: #green ;15;30079;;;;
my_cell.color;;;;;;
if peopleEnabled ;1300;1;;;;
create people from: demand_csv with: [start_hour::date(get('starttime')), start_lat::float(get('start_lat')), start_lon::float(get('start_lon')), target_lat::float(get('target_lat')), target_lon::float(get('target_lon'))];2100;14217;;;;
set speed value: peopleSpeed ;22;14216;;;;
set start_point value: to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326').location ;282;14216;;;;
to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326').location;274;14216;;;;
to_GAMA_CRS(point(start_lon,start_lat),'EPSG:4326');271;14216;;;;
point(start_lon,start_lat);19;14216;;;;
set target_point value: to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326').location ;237;14216;;;;
to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326').location;231;14216;;;;
to_GAMA_CRS(point(target_lon,target_lat),'EPSG:4326');226;14216;;;;
point(target_lon,target_lat);14;14216;;;;
set location value: start_point ;49;14216;;;;
let start_day_str type: string value: string(start_hour,'dd') ;26;14216;;;;
string(start_hour,'dd');17;14216;;;;
set start_day value: int(start_day_str) ;18;14216;;;;
int(start_day_str);12;14216;;;;
set start_day value: (week * 7) + start_day ;19;14216;;;;
(week * 7) + start_day;18;14216;;;;
week * 7;10;14216;;;;
let start_h_str type: string value: string(start_hour,'kk') ;10;14216;;;;
string(start_hour,'kk');7;14216;;;;
set start_h value: int(start_h_str) ;15;14216;;;;
int(start_h_str);10;14216;;;;
let start_min_str type: string value: string(start_hour,'mm') ;17;14216;;;;
string(start_hour,'mm');10;14216;;;;
set start_min value: int(start_min_str) ;9;14216;;;;
int(start_min_str);2;14216;;;;
set my_cell value: closest_to(cell,self) ;43;14216;;;;
closest_to(cell,self);36;14216;;;;
set my_cell.used value: true ;6;14216;;;;
my_cell.used;;;;;;
set my_cell.color value: #green ;12;14216;;;;
my_cell.color;;;;;;
set week value: week + 1 ;0;1;;;;
week + 1;0;1;;;;
create foodhotspot from: food_hotspot_csv with: [lat::float(get('center_y')), lon::float(get('center_x')), dens::int(get('density'))];1;6;;;;
set location value: to_GAMA_CRS(point(lon,lat),'EPSG:4326').location ;0;5;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326').location;0;5;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326');0;5;;;;
point(lon,lat);0;5;;;;
create userhotspot from: user_hotspot_csv with: [lat::float(get('center_y')), lon::float(get('center_x')), dens::int(get('density'))];3;11;;;;
set location value: to_GAMA_CRS(point(lon,lat),'EPSG:4326').location ;1;10;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326').location;1;10;;;;
to_GAMA_CRS(point(lon,lat),'EPSG:4326');1;10;;;;
point(lon,lat);0;10;;;;
let usedCells type: list<cell> value: cell where (each.used = true) ;0;1;;;;
cell where (each.used = true);0;1;;;;
each.used = true;0;36;;;;
each.used;0;36;;;;
loop c over: usedCells ;0;1;;;;
set c.centerRoadpoint value: closest_to(roadNetwork.vertices,c.location) ;0;22;;;;
closest_to(roadNetwork.vertices,c.location);0;22;;;;
roadNetwork.vertices;0;22;;;;
c.location;0;22;;;;
c.centerRoadpoint;;;;;;
create CellcenterPoint ;0;44;;;;
set location value: c.centerRoadpoint ;0;22;;;;
c.centerRoadpoint;0;22;;;;
write 'FINISH INITIALIZATION' ;0;1;;;;
reflex stop_simulation when: cycle >= ((((numberOfWeeks * numberOfDays) * numberOfHours) * 3600) / step) ;62;2881;;;;
cycle >= ((((numberOfWeeks * numberOfDays) * numberOfHours) * 3600) / step);39;2881;;;;
(((numberOfWeeks * numberOfDays) * numberOfHours) * 3600) / step;28;2881;;;;
((numberOfWeeks * numberOfDays) * numberOfHours) * 3600;20;2881;;;;
(numberOfWeeks * numberOfDays) * numberOfHours;17;2881;;;;
numberOfWeeks * numberOfDays;13;2881;;;;
do pause ;19;1;;;;
experiment 'Benchmarking' type: 'gui' benchmark: true title: 'Experiment Benchmarking' ;;;;;;
main_model host ;;;0;1;;
-29;;;;;;
list<Benchmarking> peers ;;;0;1;;
-199;;;;;;
list<main_model> simulations ;;;0;1;;
-27;;;;;;
main_model simulation ;;;0;1;;
-27;;;;;;
parameter 'step' <- 30.0 * #sec var: step ;;;;;;
30.0 * #sec;;;;;0;1
parameter 'rebalEnabled' <- true var: rebalEnabled ;;;;;;
parameter 'numAutonomousBikes' <- 217 var: numAutonomousBikes ;;;;;;
parameter 'dynamicFleetsizing' <- true var: dynamicFleetsizing ;;;;;;
parameter 'peopleEnabled' <- true var: peopleEnabled ;;;;;;
parameter 'packagesEnabled' <- true var: packagesEnabled ;;;;;;
parameter 'biddingEnabled' <- false var: biddingEnabled ;;;;;;
parameter 'numberOfWeeks' <- 1 var: numberOfWeeks ;;;;;;
parameter 'numberOfDays' <- 1 var: numberOfDays ;;;;;;
